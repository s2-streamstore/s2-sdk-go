// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v6.30.2
// source: s2.proto

package pb

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	fieldmaskpb "google.golang.org/protobuf/types/known/fieldmaskpb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Basin scope.
type BasinScope int32

const (
	// Unspecified basin scope.
	BasinScope_BASIN_SCOPE_UNSPECIFIED BasinScope = 0
	// aws us-east-1 region.
	BasinScope_BASIN_SCOPE_AWS_US_EAST_1 BasinScope = 1
)

// Enum value maps for BasinScope.
var (
	BasinScope_name = map[int32]string{
		0: "BASIN_SCOPE_UNSPECIFIED",
		1: "BASIN_SCOPE_AWS_US_EAST_1",
	}
	BasinScope_value = map[string]int32{
		"BASIN_SCOPE_UNSPECIFIED":   0,
		"BASIN_SCOPE_AWS_US_EAST_1": 1,
	}
)

func (x BasinScope) Enum() *BasinScope {
	p := new(BasinScope)
	*p = x
	return p
}

func (x BasinScope) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (BasinScope) Descriptor() protoreflect.EnumDescriptor {
	return file_s2_proto_enumTypes[0].Descriptor()
}

func (BasinScope) Type() protoreflect.EnumType {
	return &file_s2_proto_enumTypes[0]
}

func (x BasinScope) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use BasinScope.Descriptor instead.
func (BasinScope) EnumDescriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{0}
}

// API operations.
type Operation int32

const (
	// Unspecified operation.
	Operation_OPERATION_UNSPECIFIED Operation = 0
	// List basins.
	Operation_OPERATION_LIST_BASINS Operation = 1
	// Create a basin.
	Operation_OPERATION_CREATE_BASIN Operation = 2
	// Delete a basin.
	Operation_OPERATION_DELETE_BASIN Operation = 3
	// Update basin configuration.
	Operation_OPERATION_RECONFIGURE_BASIN Operation = 4
	// Get basin configuration.
	Operation_OPERATION_GET_BASIN_CONFIG Operation = 5
	// Issue an access token.
	Operation_OPERATION_ISSUE_ACCESS_TOKEN Operation = 6
	// Revoke an access token.
	Operation_OPERATION_REVOKE_ACCESS_TOKEN Operation = 7
	// List access tokens.
	Operation_OPERATION_LIST_ACCESS_TOKENS Operation = 8
	// List streams.
	Operation_OPERATION_LIST_STREAMS Operation = 9
	// Create a stream.
	Operation_OPERATION_CREATE_STREAM Operation = 10
	// Delete a stream.
	Operation_OPERATION_DELETE_STREAM Operation = 11
	// Get stream configuration.
	Operation_OPERATION_GET_STREAM_CONFIG Operation = 12
	// Update stream configuration.
	Operation_OPERATION_RECONFIGURE_STREAM Operation = 13
	// Check tail of a stream.
	Operation_OPERATION_CHECK_TAIL Operation = 14
	// Append records to a stream.
	Operation_OPERATION_APPEND Operation = 15
	// Read records from a stream.
	Operation_OPERATION_READ Operation = 16
	// Trim records up to a sequence number.
	Operation_OPERATION_TRIM Operation = 17
	// Set a fencing token for a stream.
	Operation_OPERATION_FENCE Operation = 18
)

// Enum value maps for Operation.
var (
	Operation_name = map[int32]string{
		0:  "OPERATION_UNSPECIFIED",
		1:  "OPERATION_LIST_BASINS",
		2:  "OPERATION_CREATE_BASIN",
		3:  "OPERATION_DELETE_BASIN",
		4:  "OPERATION_RECONFIGURE_BASIN",
		5:  "OPERATION_GET_BASIN_CONFIG",
		6:  "OPERATION_ISSUE_ACCESS_TOKEN",
		7:  "OPERATION_REVOKE_ACCESS_TOKEN",
		8:  "OPERATION_LIST_ACCESS_TOKENS",
		9:  "OPERATION_LIST_STREAMS",
		10: "OPERATION_CREATE_STREAM",
		11: "OPERATION_DELETE_STREAM",
		12: "OPERATION_GET_STREAM_CONFIG",
		13: "OPERATION_RECONFIGURE_STREAM",
		14: "OPERATION_CHECK_TAIL",
		15: "OPERATION_APPEND",
		16: "OPERATION_READ",
		17: "OPERATION_TRIM",
		18: "OPERATION_FENCE",
	}
	Operation_value = map[string]int32{
		"OPERATION_UNSPECIFIED":         0,
		"OPERATION_LIST_BASINS":         1,
		"OPERATION_CREATE_BASIN":        2,
		"OPERATION_DELETE_BASIN":        3,
		"OPERATION_RECONFIGURE_BASIN":   4,
		"OPERATION_GET_BASIN_CONFIG":    5,
		"OPERATION_ISSUE_ACCESS_TOKEN":  6,
		"OPERATION_REVOKE_ACCESS_TOKEN": 7,
		"OPERATION_LIST_ACCESS_TOKENS":  8,
		"OPERATION_LIST_STREAMS":        9,
		"OPERATION_CREATE_STREAM":       10,
		"OPERATION_DELETE_STREAM":       11,
		"OPERATION_GET_STREAM_CONFIG":   12,
		"OPERATION_RECONFIGURE_STREAM":  13,
		"OPERATION_CHECK_TAIL":          14,
		"OPERATION_APPEND":              15,
		"OPERATION_READ":                16,
		"OPERATION_TRIM":                17,
		"OPERATION_FENCE":               18,
	}
)

func (x Operation) Enum() *Operation {
	p := new(Operation)
	*p = x
	return p
}

func (x Operation) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Operation) Descriptor() protoreflect.EnumDescriptor {
	return file_s2_proto_enumTypes[1].Descriptor()
}

func (Operation) Type() protoreflect.EnumType {
	return &file_s2_proto_enumTypes[1]
}

func (x Operation) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Operation.Descriptor instead.
func (Operation) EnumDescriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{1}
}

// Storage class for recent writes.
type StorageClass int32

const (
	// Defaults to `STORAGE_CLASS_EXPRESS`.
	StorageClass_STORAGE_CLASS_UNSPECIFIED StorageClass = 0
	// Standard, which offers end-to-end latencies under 500 ms.
	StorageClass_STORAGE_CLASS_STANDARD StorageClass = 1
	// Express, which offers end-to-end latencies under 50 ms.
	StorageClass_STORAGE_CLASS_EXPRESS StorageClass = 2
)

// Enum value maps for StorageClass.
var (
	StorageClass_name = map[int32]string{
		0: "STORAGE_CLASS_UNSPECIFIED",
		1: "STORAGE_CLASS_STANDARD",
		2: "STORAGE_CLASS_EXPRESS",
	}
	StorageClass_value = map[string]int32{
		"STORAGE_CLASS_UNSPECIFIED": 0,
		"STORAGE_CLASS_STANDARD":    1,
		"STORAGE_CLASS_EXPRESS":     2,
	}
)

func (x StorageClass) Enum() *StorageClass {
	p := new(StorageClass)
	*p = x
	return p
}

func (x StorageClass) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (StorageClass) Descriptor() protoreflect.EnumDescriptor {
	return file_s2_proto_enumTypes[2].Descriptor()
}

func (StorageClass) Type() protoreflect.EnumType {
	return &file_s2_proto_enumTypes[2]
}

func (x StorageClass) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use StorageClass.Descriptor instead.
func (StorageClass) EnumDescriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{2}
}

// Timestamping mode.
// Note that arrival time is always in milliseconds since Unix epoch.
type TimestampingMode int32

const (
	// Defaults to `TIMESTAMPING_MODE_CLIENT_PREFER`.
	TimestampingMode_TIMESTAMPING_MODE_UNSPECIFIED TimestampingMode = 0
	// Prefer client-specified timestamp if present otherwise use arrival time.
	TimestampingMode_TIMESTAMPING_MODE_CLIENT_PREFER TimestampingMode = 1
	// Require a client-specified timestamp and reject the append if it is missing.
	TimestampingMode_TIMESTAMPING_MODE_CLIENT_REQUIRE TimestampingMode = 2
	// Use the arrival time and ignore any client-specified timestamp.
	TimestampingMode_TIMESTAMPING_MODE_ARRIVAL TimestampingMode = 3
)

// Enum value maps for TimestampingMode.
var (
	TimestampingMode_name = map[int32]string{
		0: "TIMESTAMPING_MODE_UNSPECIFIED",
		1: "TIMESTAMPING_MODE_CLIENT_PREFER",
		2: "TIMESTAMPING_MODE_CLIENT_REQUIRE",
		3: "TIMESTAMPING_MODE_ARRIVAL",
	}
	TimestampingMode_value = map[string]int32{
		"TIMESTAMPING_MODE_UNSPECIFIED":    0,
		"TIMESTAMPING_MODE_CLIENT_PREFER":  1,
		"TIMESTAMPING_MODE_CLIENT_REQUIRE": 2,
		"TIMESTAMPING_MODE_ARRIVAL":        3,
	}
)

func (x TimestampingMode) Enum() *TimestampingMode {
	p := new(TimestampingMode)
	*p = x
	return p
}

func (x TimestampingMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TimestampingMode) Descriptor() protoreflect.EnumDescriptor {
	return file_s2_proto_enumTypes[3].Descriptor()
}

func (TimestampingMode) Type() protoreflect.EnumType {
	return &file_s2_proto_enumTypes[3]
}

func (x TimestampingMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TimestampingMode.Descriptor instead.
func (TimestampingMode) EnumDescriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{3}
}

// Current state of the basin.
type BasinState int32

const (
	// Unspecified.
	BasinState_BASIN_STATE_UNSPECIFIED BasinState = 0
	// Basin is active.
	BasinState_BASIN_STATE_ACTIVE BasinState = 1
	// Basin is being created.
	BasinState_BASIN_STATE_CREATING BasinState = 2
	// Basin is being deleted.
	BasinState_BASIN_STATE_DELETING BasinState = 3
)

// Enum value maps for BasinState.
var (
	BasinState_name = map[int32]string{
		0: "BASIN_STATE_UNSPECIFIED",
		1: "BASIN_STATE_ACTIVE",
		2: "BASIN_STATE_CREATING",
		3: "BASIN_STATE_DELETING",
	}
	BasinState_value = map[string]int32{
		"BASIN_STATE_UNSPECIFIED": 0,
		"BASIN_STATE_ACTIVE":      1,
		"BASIN_STATE_CREATING":    2,
		"BASIN_STATE_DELETING":    3,
	}
)

func (x BasinState) Enum() *BasinState {
	p := new(BasinState)
	*p = x
	return p
}

func (x BasinState) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (BasinState) Descriptor() protoreflect.EnumDescriptor {
	return file_s2_proto_enumTypes[4].Descriptor()
}

func (BasinState) Type() protoreflect.EnumType {
	return &file_s2_proto_enumTypes[4]
}

func (x BasinState) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use BasinState.Descriptor instead.
func (BasinState) EnumDescriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{4}
}

// List basins request.
type ListBasinsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List basin names that begin with this prefix.
	Prefix string `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	// Only return basins names that lexicographically start after this name.
	// This can be the last basin name seen in a previous listing, to continue from there.
	// It must be greater than or equal to the prefix if specified.
	StartAfter string `protobuf:"bytes,2,opt,name=start_after,json=startAfter,proto3" json:"start_after,omitempty"`
	// Number of results, up to a maximum of 1000.
	Limit         *uint64 `protobuf:"varint,3,opt,name=limit,proto3,oneof" json:"limit,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListBasinsRequest) Reset() {
	*x = ListBasinsRequest{}
	mi := &file_s2_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListBasinsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListBasinsRequest) ProtoMessage() {}

func (x *ListBasinsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListBasinsRequest.ProtoReflect.Descriptor instead.
func (*ListBasinsRequest) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{0}
}

func (x *ListBasinsRequest) GetPrefix() string {
	if x != nil {
		return x.Prefix
	}
	return ""
}

func (x *ListBasinsRequest) GetStartAfter() string {
	if x != nil {
		return x.StartAfter
	}
	return ""
}

func (x *ListBasinsRequest) GetLimit() uint64 {
	if x != nil && x.Limit != nil {
		return *x.Limit
	}
	return 0
}

// List basins response.
type ListBasinsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Matching basins.
	Basins []*BasinInfo `protobuf:"bytes,1,rep,name=basins,proto3" json:"basins,omitempty"`
	// If set, indicates there are more results that can be listed with `start_after`.
	HasMore       bool `protobuf:"varint,2,opt,name=has_more,json=hasMore,proto3" json:"has_more,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListBasinsResponse) Reset() {
	*x = ListBasinsResponse{}
	mi := &file_s2_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListBasinsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListBasinsResponse) ProtoMessage() {}

func (x *ListBasinsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListBasinsResponse.ProtoReflect.Descriptor instead.
func (*ListBasinsResponse) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{1}
}

func (x *ListBasinsResponse) GetBasins() []*BasinInfo {
	if x != nil {
		return x.Basins
	}
	return nil
}

func (x *ListBasinsResponse) GetHasMore() bool {
	if x != nil {
		return x.HasMore
	}
	return false
}

// Create basin request.
type CreateBasinRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Basin name, which must be globally unique.
	// The name must be between 8 and 48 characters, comprising lowercase letters, numbers and hyphens.
	// It cannot begin or end with a hyphen.
	Basin string `protobuf:"bytes,1,opt,name=basin,proto3" json:"basin,omitempty"`
	// Basin configuration.
	Config *BasinConfig `protobuf:"bytes,2,opt,name=config,proto3" json:"config,omitempty"`
	// Basin scope.
	Scope         BasinScope `protobuf:"varint,3,opt,name=scope,proto3,enum=s2.v1alpha.BasinScope" json:"scope,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateBasinRequest) Reset() {
	*x = CreateBasinRequest{}
	mi := &file_s2_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateBasinRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateBasinRequest) ProtoMessage() {}

func (x *CreateBasinRequest) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateBasinRequest.ProtoReflect.Descriptor instead.
func (*CreateBasinRequest) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{2}
}

func (x *CreateBasinRequest) GetBasin() string {
	if x != nil {
		return x.Basin
	}
	return ""
}

func (x *CreateBasinRequest) GetConfig() *BasinConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *CreateBasinRequest) GetScope() BasinScope {
	if x != nil {
		return x.Scope
	}
	return BasinScope_BASIN_SCOPE_UNSPECIFIED
}

// Create basin response.
type CreateBasinResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Information about the newly created basin.
	Info          *BasinInfo `protobuf:"bytes,1,opt,name=info,proto3" json:"info,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateBasinResponse) Reset() {
	*x = CreateBasinResponse{}
	mi := &file_s2_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateBasinResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateBasinResponse) ProtoMessage() {}

func (x *CreateBasinResponse) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateBasinResponse.ProtoReflect.Descriptor instead.
func (*CreateBasinResponse) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{3}
}

func (x *CreateBasinResponse) GetInfo() *BasinInfo {
	if x != nil {
		return x.Info
	}
	return nil
}

// Delete basin request.
type DeleteBasinRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Name of the basin to delete.
	Basin         string `protobuf:"bytes,1,opt,name=basin,proto3" json:"basin,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteBasinRequest) Reset() {
	*x = DeleteBasinRequest{}
	mi := &file_s2_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteBasinRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteBasinRequest) ProtoMessage() {}

func (x *DeleteBasinRequest) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteBasinRequest.ProtoReflect.Descriptor instead.
func (*DeleteBasinRequest) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{4}
}

func (x *DeleteBasinRequest) GetBasin() string {
	if x != nil {
		return x.Basin
	}
	return ""
}

// Delete basin response.
type DeleteBasinResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteBasinResponse) Reset() {
	*x = DeleteBasinResponse{}
	mi := &file_s2_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteBasinResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteBasinResponse) ProtoMessage() {}

func (x *DeleteBasinResponse) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteBasinResponse.ProtoReflect.Descriptor instead.
func (*DeleteBasinResponse) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{5}
}

// Get basin configuration request.
type GetBasinConfigRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Basin name.
	Basin         string `protobuf:"bytes,1,opt,name=basin,proto3" json:"basin,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetBasinConfigRequest) Reset() {
	*x = GetBasinConfigRequest{}
	mi := &file_s2_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetBasinConfigRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetBasinConfigRequest) ProtoMessage() {}

func (x *GetBasinConfigRequest) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetBasinConfigRequest.ProtoReflect.Descriptor instead.
func (*GetBasinConfigRequest) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{6}
}

func (x *GetBasinConfigRequest) GetBasin() string {
	if x != nil {
		return x.Basin
	}
	return ""
}

// Get basin configuration response.
type GetBasinConfigResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Basin configuration.
	Config        *BasinConfig `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetBasinConfigResponse) Reset() {
	*x = GetBasinConfigResponse{}
	mi := &file_s2_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetBasinConfigResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetBasinConfigResponse) ProtoMessage() {}

func (x *GetBasinConfigResponse) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetBasinConfigResponse.ProtoReflect.Descriptor instead.
func (*GetBasinConfigResponse) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{7}
}

func (x *GetBasinConfigResponse) GetConfig() *BasinConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

// Reconfigure basin request.
type ReconfigureBasinRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Basin name.
	Basin string `protobuf:"bytes,1,opt,name=basin,proto3" json:"basin,omitempty"`
	// Basin configuration.
	Config *BasinConfig `protobuf:"bytes,2,opt,name=config,proto3" json:"config,omitempty"`
	// Specifies the pieces of configuration being updated.
	// See https://protobuf.dev/reference/protobuf/google.protobuf/#field-mask
	Mask          *fieldmaskpb.FieldMask `protobuf:"bytes,3,opt,name=mask,proto3" json:"mask,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReconfigureBasinRequest) Reset() {
	*x = ReconfigureBasinRequest{}
	mi := &file_s2_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReconfigureBasinRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReconfigureBasinRequest) ProtoMessage() {}

func (x *ReconfigureBasinRequest) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReconfigureBasinRequest.ProtoReflect.Descriptor instead.
func (*ReconfigureBasinRequest) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{8}
}

func (x *ReconfigureBasinRequest) GetBasin() string {
	if x != nil {
		return x.Basin
	}
	return ""
}

func (x *ReconfigureBasinRequest) GetConfig() *BasinConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *ReconfigureBasinRequest) GetMask() *fieldmaskpb.FieldMask {
	if x != nil {
		return x.Mask
	}
	return nil
}

// Reconfigure basin response.
type ReconfigureBasinResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Basin configuration.
	Config        *BasinConfig `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReconfigureBasinResponse) Reset() {
	*x = ReconfigureBasinResponse{}
	mi := &file_s2_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReconfigureBasinResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReconfigureBasinResponse) ProtoMessage() {}

func (x *ReconfigureBasinResponse) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReconfigureBasinResponse.ProtoReflect.Descriptor instead.
func (*ReconfigureBasinResponse) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{9}
}

func (x *ReconfigureBasinResponse) GetConfig() *BasinConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

// Issue access token request.
type IssueAccessTokenRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Access token information.
	Info          *AccessTokenInfo `protobuf:"bytes,1,opt,name=info,proto3" json:"info,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IssueAccessTokenRequest) Reset() {
	*x = IssueAccessTokenRequest{}
	mi := &file_s2_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IssueAccessTokenRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IssueAccessTokenRequest) ProtoMessage() {}

func (x *IssueAccessTokenRequest) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IssueAccessTokenRequest.ProtoReflect.Descriptor instead.
func (*IssueAccessTokenRequest) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{10}
}

func (x *IssueAccessTokenRequest) GetInfo() *AccessTokenInfo {
	if x != nil {
		return x.Info
	}
	return nil
}

// Read/Write permissions.
type ReadWritePermissions struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Read permission.
	Read bool `protobuf:"varint,1,opt,name=read,proto3" json:"read,omitempty"`
	// Write permission.
	Write         bool `protobuf:"varint,2,opt,name=write,proto3" json:"write,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReadWritePermissions) Reset() {
	*x = ReadWritePermissions{}
	mi := &file_s2_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReadWritePermissions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReadWritePermissions) ProtoMessage() {}

func (x *ReadWritePermissions) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReadWritePermissions.ProtoReflect.Descriptor instead.
func (*ReadWritePermissions) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{11}
}

func (x *ReadWritePermissions) GetRead() bool {
	if x != nil {
		return x.Read
	}
	return false
}

func (x *ReadWritePermissions) GetWrite() bool {
	if x != nil {
		return x.Write
	}
	return false
}

// Access permissions for a group.
type PermittedOperationGroups struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Access permissions at account level.
	Account *ReadWritePermissions `protobuf:"bytes,1,opt,name=account,proto3" json:"account,omitempty"`
	// Access permissions at basin level.
	Basin *ReadWritePermissions `protobuf:"bytes,2,opt,name=basin,proto3" json:"basin,omitempty"`
	// Access permissions at stream level.
	Stream        *ReadWritePermissions `protobuf:"bytes,3,opt,name=stream,proto3" json:"stream,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PermittedOperationGroups) Reset() {
	*x = PermittedOperationGroups{}
	mi := &file_s2_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PermittedOperationGroups) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PermittedOperationGroups) ProtoMessage() {}

func (x *PermittedOperationGroups) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PermittedOperationGroups.ProtoReflect.Descriptor instead.
func (*PermittedOperationGroups) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{12}
}

func (x *PermittedOperationGroups) GetAccount() *ReadWritePermissions {
	if x != nil {
		return x.Account
	}
	return nil
}

func (x *PermittedOperationGroups) GetBasin() *ReadWritePermissions {
	if x != nil {
		return x.Basin
	}
	return nil
}

func (x *PermittedOperationGroups) GetStream() *ReadWritePermissions {
	if x != nil {
		return x.Stream
	}
	return nil
}

// Revoke access token request.
type RevokeAccessTokenRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Token to revoke.
	Id            string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RevokeAccessTokenRequest) Reset() {
	*x = RevokeAccessTokenRequest{}
	mi := &file_s2_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RevokeAccessTokenRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RevokeAccessTokenRequest) ProtoMessage() {}

func (x *RevokeAccessTokenRequest) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RevokeAccessTokenRequest.ProtoReflect.Descriptor instead.
func (*RevokeAccessTokenRequest) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{13}
}

func (x *RevokeAccessTokenRequest) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

// Revoke access token response.
type RevokeAccessTokenResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Access token information.
	Info          *AccessTokenInfo `protobuf:"bytes,1,opt,name=info,proto3" json:"info,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RevokeAccessTokenResponse) Reset() {
	*x = RevokeAccessTokenResponse{}
	mi := &file_s2_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RevokeAccessTokenResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RevokeAccessTokenResponse) ProtoMessage() {}

func (x *RevokeAccessTokenResponse) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RevokeAccessTokenResponse.ProtoReflect.Descriptor instead.
func (*RevokeAccessTokenResponse) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{14}
}

func (x *RevokeAccessTokenResponse) GetInfo() *AccessTokenInfo {
	if x != nil {
		return x.Info
	}
	return nil
}

// List access tokens request.
type ListAccessTokensRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List access tokens that begin with this prefix.
	Prefix string `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	// Only return access tokens that lexicographically start after this ID.
	StartAfter string `protobuf:"bytes,2,opt,name=start_after,json=startAfter,proto3" json:"start_after,omitempty"`
	// Number of results, up to a maximum of 1000.
	Limit         *uint64 `protobuf:"varint,3,opt,name=limit,proto3,oneof" json:"limit,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListAccessTokensRequest) Reset() {
	*x = ListAccessTokensRequest{}
	mi := &file_s2_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListAccessTokensRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListAccessTokensRequest) ProtoMessage() {}

func (x *ListAccessTokensRequest) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListAccessTokensRequest.ProtoReflect.Descriptor instead.
func (*ListAccessTokensRequest) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{15}
}

func (x *ListAccessTokensRequest) GetPrefix() string {
	if x != nil {
		return x.Prefix
	}
	return ""
}

func (x *ListAccessTokensRequest) GetStartAfter() string {
	if x != nil {
		return x.StartAfter
	}
	return ""
}

func (x *ListAccessTokensRequest) GetLimit() uint64 {
	if x != nil && x.Limit != nil {
		return *x.Limit
	}
	return 0
}

// List access tokens response.
type ListAccessTokensResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Access tokens information.
	AccessTokens []*AccessTokenInfo `protobuf:"bytes,1,rep,name=access_tokens,json=accessTokens,proto3" json:"access_tokens,omitempty"`
	// If set, indicates there are more results that can be listed with `start_after`.
	HasMore       bool `protobuf:"varint,2,opt,name=has_more,json=hasMore,proto3" json:"has_more,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListAccessTokensResponse) Reset() {
	*x = ListAccessTokensResponse{}
	mi := &file_s2_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListAccessTokensResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListAccessTokensResponse) ProtoMessage() {}

func (x *ListAccessTokensResponse) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListAccessTokensResponse.ProtoReflect.Descriptor instead.
func (*ListAccessTokensResponse) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{16}
}

func (x *ListAccessTokensResponse) GetAccessTokens() []*AccessTokenInfo {
	if x != nil {
		return x.AccessTokens
	}
	return nil
}

func (x *ListAccessTokensResponse) GetHasMore() bool {
	if x != nil {
		return x.HasMore
	}
	return false
}

// Access token information.
type AccessTokenInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Access token ID.
	// It must be unique to the account and between 1 and 96 characters.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Expiration time in seconds since Unix epoch.
	// If not set, the expiration will be set to that of the requestor's token.
	ExpiresAt *uint32 `protobuf:"varint,2,opt,name=expires_at,json=expiresAt,proto3,oneof" json:"expires_at,omitempty"`
	// Namespace streams based on the configured stream-level scope, which must be a prefix.
	// Stream name arguments will be automatically prefixed, and the prefix will be stripped
	// when listing streams.
	AutoPrefixStreams bool `protobuf:"varint,3,opt,name=auto_prefix_streams,json=autoPrefixStreams,proto3" json:"auto_prefix_streams,omitempty"`
	// Access token scope.
	Scope         *AccessTokenScope `protobuf:"bytes,4,opt,name=scope,proto3" json:"scope,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AccessTokenInfo) Reset() {
	*x = AccessTokenInfo{}
	mi := &file_s2_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AccessTokenInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AccessTokenInfo) ProtoMessage() {}

func (x *AccessTokenInfo) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AccessTokenInfo.ProtoReflect.Descriptor instead.
func (*AccessTokenInfo) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{17}
}

func (x *AccessTokenInfo) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *AccessTokenInfo) GetExpiresAt() uint32 {
	if x != nil && x.ExpiresAt != nil {
		return *x.ExpiresAt
	}
	return 0
}

func (x *AccessTokenInfo) GetAutoPrefixStreams() bool {
	if x != nil {
		return x.AutoPrefixStreams
	}
	return false
}

func (x *AccessTokenInfo) GetScope() *AccessTokenScope {
	if x != nil {
		return x.Scope
	}
	return nil
}

// Access token scope.
type AccessTokenScope struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Basin names allowed.
	Basins *ResourceSet `protobuf:"bytes,1,opt,name=basins,proto3" json:"basins,omitempty"`
	// Stream names allowed.
	Streams *ResourceSet `protobuf:"bytes,2,opt,name=streams,proto3" json:"streams,omitempty"`
	// Token IDs allowed.
	AccessTokens *ResourceSet `protobuf:"bytes,3,opt,name=access_tokens,json=accessTokens,proto3" json:"access_tokens,omitempty"`
	// Access permissions at operation group level.
	OpGroups *PermittedOperationGroups `protobuf:"bytes,4,opt,name=op_groups,json=opGroups,proto3" json:"op_groups,omitempty"`
	// Operations allowed for the token.
	// A union of allowed operations and groups is used as an effective set of allowed operations.
	Ops           []Operation `protobuf:"varint,5,rep,packed,name=ops,proto3,enum=s2.v1alpha.Operation" json:"ops,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AccessTokenScope) Reset() {
	*x = AccessTokenScope{}
	mi := &file_s2_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AccessTokenScope) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AccessTokenScope) ProtoMessage() {}

func (x *AccessTokenScope) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AccessTokenScope.ProtoReflect.Descriptor instead.
func (*AccessTokenScope) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{18}
}

func (x *AccessTokenScope) GetBasins() *ResourceSet {
	if x != nil {
		return x.Basins
	}
	return nil
}

func (x *AccessTokenScope) GetStreams() *ResourceSet {
	if x != nil {
		return x.Streams
	}
	return nil
}

func (x *AccessTokenScope) GetAccessTokens() *ResourceSet {
	if x != nil {
		return x.AccessTokens
	}
	return nil
}

func (x *AccessTokenScope) GetOpGroups() *PermittedOperationGroups {
	if x != nil {
		return x.OpGroups
	}
	return nil
}

func (x *AccessTokenScope) GetOps() []Operation {
	if x != nil {
		return x.Ops
	}
	return nil
}

// Set of named resources.
type ResourceSet struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Matching rule.
	//
	// Types that are valid to be assigned to Matching:
	//
	//	*ResourceSet_Exact
	//	*ResourceSet_Prefix
	Matching      isResourceSet_Matching `protobuf_oneof:"matching"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ResourceSet) Reset() {
	*x = ResourceSet{}
	mi := &file_s2_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ResourceSet) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ResourceSet) ProtoMessage() {}

func (x *ResourceSet) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ResourceSet.ProtoReflect.Descriptor instead.
func (*ResourceSet) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{19}
}

func (x *ResourceSet) GetMatching() isResourceSet_Matching {
	if x != nil {
		return x.Matching
	}
	return nil
}

func (x *ResourceSet) GetExact() string {
	if x != nil {
		if x, ok := x.Matching.(*ResourceSet_Exact); ok {
			return x.Exact
		}
	}
	return ""
}

func (x *ResourceSet) GetPrefix() string {
	if x != nil {
		if x, ok := x.Matching.(*ResourceSet_Prefix); ok {
			return x.Prefix
		}
	}
	return ""
}

type isResourceSet_Matching interface {
	isResourceSet_Matching()
}

type ResourceSet_Exact struct {
	// Match only the resource with this exact name.
	// Use an empty string to match no resources.
	Exact string `protobuf:"bytes,1,opt,name=exact,proto3,oneof"`
}

type ResourceSet_Prefix struct {
	// Match all resources that start with this prefix.
	// Use an empty string to match all resource.
	Prefix string `protobuf:"bytes,2,opt,name=prefix,proto3,oneof"`
}

func (*ResourceSet_Exact) isResourceSet_Matching() {}

func (*ResourceSet_Prefix) isResourceSet_Matching() {}

// Issue access token response.
type IssueAccessTokenResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Created access token.
	AccessToken   string `protobuf:"bytes,1,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IssueAccessTokenResponse) Reset() {
	*x = IssueAccessTokenResponse{}
	mi := &file_s2_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IssueAccessTokenResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IssueAccessTokenResponse) ProtoMessage() {}

func (x *IssueAccessTokenResponse) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IssueAccessTokenResponse.ProtoReflect.Descriptor instead.
func (*IssueAccessTokenResponse) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{20}
}

func (x *IssueAccessTokenResponse) GetAccessToken() string {
	if x != nil {
		return x.AccessToken
	}
	return ""
}

// Stream information.
type StreamInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Stream name.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Creation time in seconds since Unix epoch.
	CreatedAt uint32 `protobuf:"varint,2,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// Deletion time in seconds since Unix epoch, if the stream is being deleted.
	DeletedAt     *uint32 `protobuf:"varint,3,opt,name=deleted_at,json=deletedAt,proto3,oneof" json:"deleted_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamInfo) Reset() {
	*x = StreamInfo{}
	mi := &file_s2_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamInfo) ProtoMessage() {}

func (x *StreamInfo) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamInfo.ProtoReflect.Descriptor instead.
func (*StreamInfo) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{21}
}

func (x *StreamInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *StreamInfo) GetCreatedAt() uint32 {
	if x != nil {
		return x.CreatedAt
	}
	return 0
}

func (x *StreamInfo) GetDeletedAt() uint32 {
	if x != nil && x.DeletedAt != nil {
		return *x.DeletedAt
	}
	return 0
}

// List streams request.
type ListStreamsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List stream names that begin with this prefix.
	Prefix string `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	// Only return stream names that lexicographically start after this name.
	// This can be the last stream name seen in a previous listing, to continue from there.
	// It must be greater than or equal to the prefix if specified.
	StartAfter string `protobuf:"bytes,2,opt,name=start_after,json=startAfter,proto3" json:"start_after,omitempty"`
	// Number of results, up to a maximum of 1000.
	Limit         *uint64 `protobuf:"varint,3,opt,name=limit,proto3,oneof" json:"limit,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListStreamsRequest) Reset() {
	*x = ListStreamsRequest{}
	mi := &file_s2_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListStreamsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListStreamsRequest) ProtoMessage() {}

func (x *ListStreamsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListStreamsRequest.ProtoReflect.Descriptor instead.
func (*ListStreamsRequest) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{22}
}

func (x *ListStreamsRequest) GetPrefix() string {
	if x != nil {
		return x.Prefix
	}
	return ""
}

func (x *ListStreamsRequest) GetStartAfter() string {
	if x != nil {
		return x.StartAfter
	}
	return ""
}

func (x *ListStreamsRequest) GetLimit() uint64 {
	if x != nil && x.Limit != nil {
		return *x.Limit
	}
	return 0
}

// List streams response.
type ListStreamsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Matching streams.
	Streams []*StreamInfo `protobuf:"bytes,1,rep,name=streams,proto3" json:"streams,omitempty"`
	// If set, indicates there are more results that can be listed with `start_after`.
	HasMore       bool `protobuf:"varint,2,opt,name=has_more,json=hasMore,proto3" json:"has_more,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListStreamsResponse) Reset() {
	*x = ListStreamsResponse{}
	mi := &file_s2_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListStreamsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListStreamsResponse) ProtoMessage() {}

func (x *ListStreamsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListStreamsResponse.ProtoReflect.Descriptor instead.
func (*ListStreamsResponse) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{23}
}

func (x *ListStreamsResponse) GetStreams() []*StreamInfo {
	if x != nil {
		return x.Streams
	}
	return nil
}

func (x *ListStreamsResponse) GetHasMore() bool {
	if x != nil {
		return x.HasMore
	}
	return false
}

// Create stream request.
type CreateStreamRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Stream name, which must be unique within the basin.
	// It can be an arbitrary string upto 512 characters.
	// Backslash (`/`) is recommended as a delimiter for hierarchical naming.
	Stream string `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	// Configuration for the new stream.
	Config        *StreamConfig `protobuf:"bytes,2,opt,name=config,proto3" json:"config,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateStreamRequest) Reset() {
	*x = CreateStreamRequest{}
	mi := &file_s2_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateStreamRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateStreamRequest) ProtoMessage() {}

func (x *CreateStreamRequest) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateStreamRequest.ProtoReflect.Descriptor instead.
func (*CreateStreamRequest) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{24}
}

func (x *CreateStreamRequest) GetStream() string {
	if x != nil {
		return x.Stream
	}
	return ""
}

func (x *CreateStreamRequest) GetConfig() *StreamConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

// Create stream response.
type CreateStreamResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Information about the newly created stream.
	Info          *StreamInfo `protobuf:"bytes,1,opt,name=info,proto3" json:"info,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateStreamResponse) Reset() {
	*x = CreateStreamResponse{}
	mi := &file_s2_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateStreamResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateStreamResponse) ProtoMessage() {}

func (x *CreateStreamResponse) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateStreamResponse.ProtoReflect.Descriptor instead.
func (*CreateStreamResponse) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{25}
}

func (x *CreateStreamResponse) GetInfo() *StreamInfo {
	if x != nil {
		return x.Info
	}
	return nil
}

// Delete stream request.
type DeleteStreamRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Stream name.
	Stream        string `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteStreamRequest) Reset() {
	*x = DeleteStreamRequest{}
	mi := &file_s2_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteStreamRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteStreamRequest) ProtoMessage() {}

func (x *DeleteStreamRequest) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteStreamRequest.ProtoReflect.Descriptor instead.
func (*DeleteStreamRequest) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{26}
}

func (x *DeleteStreamRequest) GetStream() string {
	if x != nil {
		return x.Stream
	}
	return ""
}

// Delete stream response.
type DeleteStreamResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteStreamResponse) Reset() {
	*x = DeleteStreamResponse{}
	mi := &file_s2_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteStreamResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteStreamResponse) ProtoMessage() {}

func (x *DeleteStreamResponse) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteStreamResponse.ProtoReflect.Descriptor instead.
func (*DeleteStreamResponse) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{27}
}

// Get stream configuration request.
type GetStreamConfigRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Stream name.
	Stream        string `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetStreamConfigRequest) Reset() {
	*x = GetStreamConfigRequest{}
	mi := &file_s2_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetStreamConfigRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetStreamConfigRequest) ProtoMessage() {}

func (x *GetStreamConfigRequest) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetStreamConfigRequest.ProtoReflect.Descriptor instead.
func (*GetStreamConfigRequest) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{28}
}

func (x *GetStreamConfigRequest) GetStream() string {
	if x != nil {
		return x.Stream
	}
	return ""
}

// Get stream configuration response.
type GetStreamConfigResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Stream configuration.
	Config        *StreamConfig `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetStreamConfigResponse) Reset() {
	*x = GetStreamConfigResponse{}
	mi := &file_s2_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetStreamConfigResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetStreamConfigResponse) ProtoMessage() {}

func (x *GetStreamConfigResponse) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetStreamConfigResponse.ProtoReflect.Descriptor instead.
func (*GetStreamConfigResponse) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{29}
}

func (x *GetStreamConfigResponse) GetConfig() *StreamConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

// Reconfigure stream request.
type ReconfigureStreamRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Stream name.
	Stream string `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	// Stream configuration with updated values.
	Config *StreamConfig `protobuf:"bytes,2,opt,name=config,proto3" json:"config,omitempty"`
	// Specifies the pieces of configuration being updated.
	// See https://protobuf.dev/reference/protobuf/google.protobuf/#field-mask
	Mask          *fieldmaskpb.FieldMask `protobuf:"bytes,3,opt,name=mask,proto3" json:"mask,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReconfigureStreamRequest) Reset() {
	*x = ReconfigureStreamRequest{}
	mi := &file_s2_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReconfigureStreamRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReconfigureStreamRequest) ProtoMessage() {}

func (x *ReconfigureStreamRequest) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReconfigureStreamRequest.ProtoReflect.Descriptor instead.
func (*ReconfigureStreamRequest) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{30}
}

func (x *ReconfigureStreamRequest) GetStream() string {
	if x != nil {
		return x.Stream
	}
	return ""
}

func (x *ReconfigureStreamRequest) GetConfig() *StreamConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *ReconfigureStreamRequest) GetMask() *fieldmaskpb.FieldMask {
	if x != nil {
		return x.Mask
	}
	return nil
}

// Reconfigure stream response.
type ReconfigureStreamResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Stream configuration.
	Config        *StreamConfig `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReconfigureStreamResponse) Reset() {
	*x = ReconfigureStreamResponse{}
	mi := &file_s2_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReconfigureStreamResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReconfigureStreamResponse) ProtoMessage() {}

func (x *ReconfigureStreamResponse) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReconfigureStreamResponse.ProtoReflect.Descriptor instead.
func (*ReconfigureStreamResponse) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{31}
}

func (x *ReconfigureStreamResponse) GetConfig() *StreamConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

// Check tail request.
type CheckTailRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Stream name.
	Stream        string `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CheckTailRequest) Reset() {
	*x = CheckTailRequest{}
	mi := &file_s2_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CheckTailRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CheckTailRequest) ProtoMessage() {}

func (x *CheckTailRequest) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CheckTailRequest.ProtoReflect.Descriptor instead.
func (*CheckTailRequest) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{32}
}

func (x *CheckTailRequest) GetStream() string {
	if x != nil {
		return x.Stream
	}
	return ""
}

// Check tail response.
type CheckTailResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Sequence number that will be assigned to the next record on the stream.
	// It will be 0 for a stream that has not been written to.
	NextSeqNum uint64 `protobuf:"varint,1,opt,name=next_seq_num,json=nextSeqNum,proto3" json:"next_seq_num,omitempty"`
	// Timestamp of the last durable record on the stream.
	// It starts out as 0 for a new stream.
	LastTimestamp uint64 `protobuf:"varint,2,opt,name=last_timestamp,json=lastTimestamp,proto3" json:"last_timestamp,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CheckTailResponse) Reset() {
	*x = CheckTailResponse{}
	mi := &file_s2_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CheckTailResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CheckTailResponse) ProtoMessage() {}

func (x *CheckTailResponse) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CheckTailResponse.ProtoReflect.Descriptor instead.
func (*CheckTailResponse) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{33}
}

func (x *CheckTailResponse) GetNextSeqNum() uint64 {
	if x != nil {
		return x.NextSeqNum
	}
	return 0
}

func (x *CheckTailResponse) GetLastTimestamp() uint64 {
	if x != nil {
		return x.LastTimestamp
	}
	return 0
}

// Input for append requests.
type AppendInput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Stream name. Optional for subsequent requests in the session.
	Stream string `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	// Batch of records to append atomically, which must contain at least one record, and no more than 1000.
	// The total size of a batch of records may not exceed 1MiB of metered bytes.
	Records []*AppendRecord `protobuf:"bytes,2,rep,name=records,proto3" json:"records,omitempty"`
	// Enforce that the sequence number issued to the first record matches.
	MatchSeqNum *uint64 `protobuf:"varint,3,opt,name=match_seq_num,json=matchSeqNum,proto3,oneof" json:"match_seq_num,omitempty"`
	// Enforce a fencing token which must have been previously set by a `fence` command record.
	FencingToken  []byte `protobuf:"bytes,4,opt,name=fencing_token,json=fencingToken,proto3,oneof" json:"fencing_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AppendInput) Reset() {
	*x = AppendInput{}
	mi := &file_s2_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AppendInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AppendInput) ProtoMessage() {}

func (x *AppendInput) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AppendInput.ProtoReflect.Descriptor instead.
func (*AppendInput) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{34}
}

func (x *AppendInput) GetStream() string {
	if x != nil {
		return x.Stream
	}
	return ""
}

func (x *AppendInput) GetRecords() []*AppendRecord {
	if x != nil {
		return x.Records
	}
	return nil
}

func (x *AppendInput) GetMatchSeqNum() uint64 {
	if x != nil && x.MatchSeqNum != nil {
		return *x.MatchSeqNum
	}
	return 0
}

func (x *AppendInput) GetFencingToken() []byte {
	if x != nil {
		return x.FencingToken
	}
	return nil
}

// Output from append response.
type AppendOutput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Sequence number of first record appended.
	StartSeqNum uint64 `protobuf:"varint,1,opt,name=start_seq_num,json=startSeqNum,proto3" json:"start_seq_num,omitempty"`
	// Timestamp of the first record appended.
	StartTimestamp uint64 `protobuf:"varint,4,opt,name=start_timestamp,json=startTimestamp,proto3" json:"start_timestamp,omitempty"`
	// Sequence number of last record appended + 1.
	// `end_seq_num - start_seq_num` will be the number of records in the batch.
	EndSeqNum uint64 `protobuf:"varint,2,opt,name=end_seq_num,json=endSeqNum,proto3" json:"end_seq_num,omitempty"`
	// Timestamp of the last record appended.
	EndTimestamp uint64 `protobuf:"varint,5,opt,name=end_timestamp,json=endTimestamp,proto3" json:"end_timestamp,omitempty"`
	// Tail of the stream, i.e. sequence number that will be assigned to the next record.
	// This can be greater than `end_seq_num` in case of concurrent appends.
	NextSeqNum uint64 `protobuf:"varint,3,opt,name=next_seq_num,json=nextSeqNum,proto3" json:"next_seq_num,omitempty"`
	// Timestamp of the last durable record on the stream.
	LastTimestamp uint64 `protobuf:"varint,6,opt,name=last_timestamp,json=lastTimestamp,proto3" json:"last_timestamp,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AppendOutput) Reset() {
	*x = AppendOutput{}
	mi := &file_s2_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AppendOutput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AppendOutput) ProtoMessage() {}

func (x *AppendOutput) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AppendOutput.ProtoReflect.Descriptor instead.
func (*AppendOutput) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{35}
}

func (x *AppendOutput) GetStartSeqNum() uint64 {
	if x != nil {
		return x.StartSeqNum
	}
	return 0
}

func (x *AppendOutput) GetStartTimestamp() uint64 {
	if x != nil {
		return x.StartTimestamp
	}
	return 0
}

func (x *AppendOutput) GetEndSeqNum() uint64 {
	if x != nil {
		return x.EndSeqNum
	}
	return 0
}

func (x *AppendOutput) GetEndTimestamp() uint64 {
	if x != nil {
		return x.EndTimestamp
	}
	return 0
}

func (x *AppendOutput) GetNextSeqNum() uint64 {
	if x != nil {
		return x.NextSeqNum
	}
	return 0
}

func (x *AppendOutput) GetLastTimestamp() uint64 {
	if x != nil {
		return x.LastTimestamp
	}
	return 0
}

// Append request.
type AppendRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Request parameters for an append.
	Input         *AppendInput `protobuf:"bytes,1,opt,name=input,proto3" json:"input,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AppendRequest) Reset() {
	*x = AppendRequest{}
	mi := &file_s2_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AppendRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AppendRequest) ProtoMessage() {}

func (x *AppendRequest) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AppendRequest.ProtoReflect.Descriptor instead.
func (*AppendRequest) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{36}
}

func (x *AppendRequest) GetInput() *AppendInput {
	if x != nil {
		return x.Input
	}
	return nil
}

// Append response.
type AppendResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Response details for an append.
	Output        *AppendOutput `protobuf:"bytes,1,opt,name=output,proto3" json:"output,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AppendResponse) Reset() {
	*x = AppendResponse{}
	mi := &file_s2_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AppendResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AppendResponse) ProtoMessage() {}

func (x *AppendResponse) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AppendResponse.ProtoReflect.Descriptor instead.
func (*AppendResponse) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{37}
}

func (x *AppendResponse) GetOutput() *AppendOutput {
	if x != nil {
		return x.Output
	}
	return nil
}

// Append session request.
type AppendSessionRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Request parameters for an append.
	Input         *AppendInput `protobuf:"bytes,1,opt,name=input,proto3" json:"input,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AppendSessionRequest) Reset() {
	*x = AppendSessionRequest{}
	mi := &file_s2_proto_msgTypes[38]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AppendSessionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AppendSessionRequest) ProtoMessage() {}

func (x *AppendSessionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[38]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AppendSessionRequest.ProtoReflect.Descriptor instead.
func (*AppendSessionRequest) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{38}
}

func (x *AppendSessionRequest) GetInput() *AppendInput {
	if x != nil {
		return x.Input
	}
	return nil
}

// Append session response.
type AppendSessionResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Response details for an append.
	Output        *AppendOutput `protobuf:"bytes,1,opt,name=output,proto3" json:"output,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AppendSessionResponse) Reset() {
	*x = AppendSessionResponse{}
	mi := &file_s2_proto_msgTypes[39]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AppendSessionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AppendSessionResponse) ProtoMessage() {}

func (x *AppendSessionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[39]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AppendSessionResponse.ProtoReflect.Descriptor instead.
func (*AppendSessionResponse) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{39}
}

func (x *AppendSessionResponse) GetOutput() *AppendOutput {
	if x != nil {
		return x.Output
	}
	return nil
}

// Output of a read.
type ReadOutput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Batch of records or the next sequence number on the stream.
	//
	// Types that are valid to be assigned to Output:
	//
	//	*ReadOutput_Batch
	//	*ReadOutput_NextSeqNum
	Output        isReadOutput_Output `protobuf_oneof:"output"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReadOutput) Reset() {
	*x = ReadOutput{}
	mi := &file_s2_proto_msgTypes[40]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReadOutput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReadOutput) ProtoMessage() {}

func (x *ReadOutput) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[40]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReadOutput.ProtoReflect.Descriptor instead.
func (*ReadOutput) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{40}
}

func (x *ReadOutput) GetOutput() isReadOutput_Output {
	if x != nil {
		return x.Output
	}
	return nil
}

func (x *ReadOutput) GetBatch() *SequencedRecordBatch {
	if x != nil {
		if x, ok := x.Output.(*ReadOutput_Batch); ok {
			return x.Batch
		}
	}
	return nil
}

func (x *ReadOutput) GetNextSeqNum() uint64 {
	if x != nil {
		if x, ok := x.Output.(*ReadOutput_NextSeqNum); ok {
			return x.NextSeqNum
		}
	}
	return 0
}

type isReadOutput_Output interface {
	isReadOutput_Output()
}

type ReadOutput_Batch struct {
	// Batch of records.
	// It can only be empty when not in a session context,
	// if the request cannot be satisfied without violating its limit.
	Batch *SequencedRecordBatch `protobuf:"bytes,1,opt,name=batch,proto3,oneof"`
}

type ReadOutput_NextSeqNum struct {
	// Tail of the stream, i.e. sequence number that will be assigned to the next record.
	// It will be returned if the requested starting position is greater than the tail,
	// or only in case of a limited read, equal to it.
	// It will also be returned if there are no records on the stream between the
	// requested starting position and the tail.
	NextSeqNum uint64 `protobuf:"varint,3,opt,name=next_seq_num,json=nextSeqNum,proto3,oneof"`
}

func (*ReadOutput_Batch) isReadOutput_Output() {}

func (*ReadOutput_NextSeqNum) isReadOutput_Output() {}

// Read request.
type ReadRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Stream name.
	Stream string `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	// Starting position for records.
	// Retrieved batches will start at the first record whose position is greater than or equal to it.
	//
	// Types that are valid to be assigned to Start:
	//
	//	*ReadRequest_SeqNum
	//	*ReadRequest_Timestamp
	//	*ReadRequest_TailOffset
	Start isReadRequest_Start `protobuf_oneof:"start"`
	// Limit how many records can be returned.
	// This will get capped at the default limit,
	// which is up to 1000 records or 1MiB of metered bytes.
	Limit         *ReadLimit `protobuf:"bytes,3,opt,name=limit,proto3" json:"limit,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReadRequest) Reset() {
	*x = ReadRequest{}
	mi := &file_s2_proto_msgTypes[41]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReadRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReadRequest) ProtoMessage() {}

func (x *ReadRequest) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[41]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReadRequest.ProtoReflect.Descriptor instead.
func (*ReadRequest) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{41}
}

func (x *ReadRequest) GetStream() string {
	if x != nil {
		return x.Stream
	}
	return ""
}

func (x *ReadRequest) GetStart() isReadRequest_Start {
	if x != nil {
		return x.Start
	}
	return nil
}

func (x *ReadRequest) GetSeqNum() uint64 {
	if x != nil {
		if x, ok := x.Start.(*ReadRequest_SeqNum); ok {
			return x.SeqNum
		}
	}
	return 0
}

func (x *ReadRequest) GetTimestamp() uint64 {
	if x != nil {
		if x, ok := x.Start.(*ReadRequest_Timestamp); ok {
			return x.Timestamp
		}
	}
	return 0
}

func (x *ReadRequest) GetTailOffset() uint64 {
	if x != nil {
		if x, ok := x.Start.(*ReadRequest_TailOffset); ok {
			return x.TailOffset
		}
	}
	return 0
}

func (x *ReadRequest) GetLimit() *ReadLimit {
	if x != nil {
		return x.Limit
	}
	return nil
}

type isReadRequest_Start interface {
	isReadRequest_Start()
}

type ReadRequest_SeqNum struct {
	// Sequence number.
	SeqNum uint64 `protobuf:"varint,2,opt,name=seq_num,json=seqNum,proto3,oneof"`
}

type ReadRequest_Timestamp struct {
	// Timestamp.
	Timestamp uint64 `protobuf:"varint,4,opt,name=timestamp,proto3,oneof"`
}

type ReadRequest_TailOffset struct {
	// Number of records before the tail, i.e. before the next sequence number.
	TailOffset uint64 `protobuf:"varint,5,opt,name=tail_offset,json=tailOffset,proto3,oneof"`
}

func (*ReadRequest_SeqNum) isReadRequest_Start() {}

func (*ReadRequest_Timestamp) isReadRequest_Start() {}

func (*ReadRequest_TailOffset) isReadRequest_Start() {}

// Read response.
type ReadResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Response details for a read.
	Output        *ReadOutput `protobuf:"bytes,1,opt,name=output,proto3" json:"output,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReadResponse) Reset() {
	*x = ReadResponse{}
	mi := &file_s2_proto_msgTypes[42]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReadResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReadResponse) ProtoMessage() {}

func (x *ReadResponse) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[42]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReadResponse.ProtoReflect.Descriptor instead.
func (*ReadResponse) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{42}
}

func (x *ReadResponse) GetOutput() *ReadOutput {
	if x != nil {
		return x.Output
	}
	return nil
}

// Limit how many records can be retrieved.
// If both count and bytes are specified, either limit may be hit.
type ReadLimit struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Record count limit.
	Count *uint64 `protobuf:"varint,1,opt,name=count,proto3,oneof" json:"count,omitempty"`
	// Metered bytes limit.
	Bytes         *uint64 `protobuf:"varint,2,opt,name=bytes,proto3,oneof" json:"bytes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReadLimit) Reset() {
	*x = ReadLimit{}
	mi := &file_s2_proto_msgTypes[43]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReadLimit) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReadLimit) ProtoMessage() {}

func (x *ReadLimit) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[43]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReadLimit.ProtoReflect.Descriptor instead.
func (*ReadLimit) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{43}
}

func (x *ReadLimit) GetCount() uint64 {
	if x != nil && x.Count != nil {
		return *x.Count
	}
	return 0
}

func (x *ReadLimit) GetBytes() uint64 {
	if x != nil && x.Bytes != nil {
		return *x.Bytes
	}
	return 0
}

// Read session request.
type ReadSessionRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Stream name.
	Stream string `protobuf:"bytes,1,opt,name=stream,proto3" json:"stream,omitempty"`
	// Starting position for records.
	// Retrieved batches will start at the first record whose position is greater than or equal to it.
	//
	// Types that are valid to be assigned to Start:
	//
	//	*ReadSessionRequest_SeqNum
	//	*ReadSessionRequest_Timestamp
	//	*ReadSessionRequest_TailOffset
	Start isReadSessionRequest_Start `protobuf_oneof:"start"`
	// Limit on how many records can be returned. When a limit is specified, the session will be terminated as soon as
	// the limit is met, or when the current tail of the stream is reached -- whichever occurs first.
	// If no limit is specified, the session will remain open after catching up to the tail, and continue tailing as
	// new messages are written to the stream.
	Limit *ReadLimit `protobuf:"bytes,3,opt,name=limit,proto3" json:"limit,omitempty"`
	// Heartbeats can be enabled to monitor end-to-end session health.
	// A heartbeat will be sent when the initial switch to real-time tailing happens,
	// as well as when no records are available at a randomized interval between 5 and 15 seconds.
	Heartbeats    bool `protobuf:"varint,4,opt,name=heartbeats,proto3" json:"heartbeats,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReadSessionRequest) Reset() {
	*x = ReadSessionRequest{}
	mi := &file_s2_proto_msgTypes[44]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReadSessionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReadSessionRequest) ProtoMessage() {}

func (x *ReadSessionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[44]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReadSessionRequest.ProtoReflect.Descriptor instead.
func (*ReadSessionRequest) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{44}
}

func (x *ReadSessionRequest) GetStream() string {
	if x != nil {
		return x.Stream
	}
	return ""
}

func (x *ReadSessionRequest) GetStart() isReadSessionRequest_Start {
	if x != nil {
		return x.Start
	}
	return nil
}

func (x *ReadSessionRequest) GetSeqNum() uint64 {
	if x != nil {
		if x, ok := x.Start.(*ReadSessionRequest_SeqNum); ok {
			return x.SeqNum
		}
	}
	return 0
}

func (x *ReadSessionRequest) GetTimestamp() uint64 {
	if x != nil {
		if x, ok := x.Start.(*ReadSessionRequest_Timestamp); ok {
			return x.Timestamp
		}
	}
	return 0
}

func (x *ReadSessionRequest) GetTailOffset() uint64 {
	if x != nil {
		if x, ok := x.Start.(*ReadSessionRequest_TailOffset); ok {
			return x.TailOffset
		}
	}
	return 0
}

func (x *ReadSessionRequest) GetLimit() *ReadLimit {
	if x != nil {
		return x.Limit
	}
	return nil
}

func (x *ReadSessionRequest) GetHeartbeats() bool {
	if x != nil {
		return x.Heartbeats
	}
	return false
}

type isReadSessionRequest_Start interface {
	isReadSessionRequest_Start()
}

type ReadSessionRequest_SeqNum struct {
	// Sequence number.
	SeqNum uint64 `protobuf:"varint,2,opt,name=seq_num,json=seqNum,proto3,oneof"`
}

type ReadSessionRequest_Timestamp struct {
	// Timestamp.
	Timestamp uint64 `protobuf:"varint,5,opt,name=timestamp,proto3,oneof"`
}

type ReadSessionRequest_TailOffset struct {
	// Number of records before the tail, i.e. the next sequence number.
	TailOffset uint64 `protobuf:"varint,6,opt,name=tail_offset,json=tailOffset,proto3,oneof"`
}

func (*ReadSessionRequest_SeqNum) isReadSessionRequest_Start() {}

func (*ReadSessionRequest_Timestamp) isReadSessionRequest_Start() {}

func (*ReadSessionRequest_TailOffset) isReadSessionRequest_Start() {}

// Read session response.
type ReadSessionResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Response details for a read.
	// This will not be set in case of a heartbeat message.
	Output        *ReadOutput `protobuf:"bytes,1,opt,name=output,proto3,oneof" json:"output,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReadSessionResponse) Reset() {
	*x = ReadSessionResponse{}
	mi := &file_s2_proto_msgTypes[45]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReadSessionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReadSessionResponse) ProtoMessage() {}

func (x *ReadSessionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[45]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReadSessionResponse.ProtoReflect.Descriptor instead.
func (*ReadSessionResponse) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{45}
}

func (x *ReadSessionResponse) GetOutput() *ReadOutput {
	if x != nil {
		return x.Output
	}
	return nil
}

// Stream configuration.
type StreamConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Storage class for recent writes.
	StorageClass StorageClass `protobuf:"varint,1,opt,name=storage_class,json=storageClass,proto3,enum=s2.v1alpha.StorageClass" json:"storage_class,omitempty"`
	// Retention policy for the stream.
	// If unspecified, the default is to retain records for 7 days.
	//
	// Types that are valid to be assigned to RetentionPolicy:
	//
	//	*StreamConfig_Age
	RetentionPolicy isStreamConfig_RetentionPolicy `protobuf_oneof:"retention_policy"`
	// Timestamping behavior.
	Timestamping  *StreamConfig_Timestamping `protobuf:"bytes,5,opt,name=timestamping,proto3" json:"timestamping,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamConfig) Reset() {
	*x = StreamConfig{}
	mi := &file_s2_proto_msgTypes[46]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamConfig) ProtoMessage() {}

func (x *StreamConfig) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[46]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamConfig.ProtoReflect.Descriptor instead.
func (*StreamConfig) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{46}
}

func (x *StreamConfig) GetStorageClass() StorageClass {
	if x != nil {
		return x.StorageClass
	}
	return StorageClass_STORAGE_CLASS_UNSPECIFIED
}

func (x *StreamConfig) GetRetentionPolicy() isStreamConfig_RetentionPolicy {
	if x != nil {
		return x.RetentionPolicy
	}
	return nil
}

func (x *StreamConfig) GetAge() uint64 {
	if x != nil {
		if x, ok := x.RetentionPolicy.(*StreamConfig_Age); ok {
			return x.Age
		}
	}
	return 0
}

func (x *StreamConfig) GetTimestamping() *StreamConfig_Timestamping {
	if x != nil {
		return x.Timestamping
	}
	return nil
}

type isStreamConfig_RetentionPolicy interface {
	isStreamConfig_RetentionPolicy()
}

type StreamConfig_Age struct {
	// Age in seconds for automatic trimming of records older than this threshold.
	// If set to 0, the stream will have infinite retention.
	Age uint64 `protobuf:"varint,2,opt,name=age,proto3,oneof"`
}

func (*StreamConfig_Age) isStreamConfig_RetentionPolicy() {}

// Basin configuration.
type BasinConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Default stream configuration.
	DefaultStreamConfig *StreamConfig `protobuf:"bytes,1,opt,name=default_stream_config,json=defaultStreamConfig,proto3" json:"default_stream_config,omitempty"`
	// Create stream on append if it doesn't exist,
	// using the default stream configuration.
	CreateStreamOnAppend bool `protobuf:"varint,2,opt,name=create_stream_on_append,json=createStreamOnAppend,proto3" json:"create_stream_on_append,omitempty"`
	// Create stream on read if it doesn't exist,
	// using the default stream configuration.
	CreateStreamOnRead bool `protobuf:"varint,3,opt,name=create_stream_on_read,json=createStreamOnRead,proto3" json:"create_stream_on_read,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *BasinConfig) Reset() {
	*x = BasinConfig{}
	mi := &file_s2_proto_msgTypes[47]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BasinConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BasinConfig) ProtoMessage() {}

func (x *BasinConfig) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[47]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BasinConfig.ProtoReflect.Descriptor instead.
func (*BasinConfig) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{47}
}

func (x *BasinConfig) GetDefaultStreamConfig() *StreamConfig {
	if x != nil {
		return x.DefaultStreamConfig
	}
	return nil
}

func (x *BasinConfig) GetCreateStreamOnAppend() bool {
	if x != nil {
		return x.CreateStreamOnAppend
	}
	return false
}

func (x *BasinConfig) GetCreateStreamOnRead() bool {
	if x != nil {
		return x.CreateStreamOnRead
	}
	return false
}

// Basin information.
type BasinInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Basin name.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Basin scope.
	Scope BasinScope `protobuf:"varint,5,opt,name=scope,proto3,enum=s2.v1alpha.BasinScope" json:"scope,omitempty"`
	// Basin state.
	State         BasinState `protobuf:"varint,4,opt,name=state,proto3,enum=s2.v1alpha.BasinState" json:"state,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BasinInfo) Reset() {
	*x = BasinInfo{}
	mi := &file_s2_proto_msgTypes[48]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BasinInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BasinInfo) ProtoMessage() {}

func (x *BasinInfo) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[48]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BasinInfo.ProtoReflect.Descriptor instead.
func (*BasinInfo) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{48}
}

func (x *BasinInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *BasinInfo) GetScope() BasinScope {
	if x != nil {
		return x.Scope
	}
	return BasinScope_BASIN_SCOPE_UNSPECIFIED
}

func (x *BasinInfo) GetState() BasinState {
	if x != nil {
		return x.State
	}
	return BasinState_BASIN_STATE_UNSPECIFIED
}

// Headers add structured information to a record as name-value pairs.
type Header struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Header name blob.
	// The name cannot be empty, with the exception of an S2 command record.
	Name []byte `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Header value blob.
	Value         []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Header) Reset() {
	*x = Header{}
	mi := &file_s2_proto_msgTypes[49]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Header) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Header) ProtoMessage() {}

func (x *Header) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[49]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Header.ProtoReflect.Descriptor instead.
func (*Header) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{49}
}

func (x *Header) GetName() []byte {
	if x != nil {
		return x.Name
	}
	return nil
}

func (x *Header) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

// Record to be appended to a stream.
type AppendRecord struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Timestamp for this record.
	// Precise semantics depend on the stream's `timestamping` config.
	Timestamp *uint64 `protobuf:"varint,3,opt,name=timestamp,proto3,oneof" json:"timestamp,omitempty"`
	// Series of name-value pairs for this record.
	Headers []*Header `protobuf:"bytes,1,rep,name=headers,proto3" json:"headers,omitempty"`
	// Body of this record.
	Body          []byte `protobuf:"bytes,2,opt,name=body,proto3" json:"body,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AppendRecord) Reset() {
	*x = AppendRecord{}
	mi := &file_s2_proto_msgTypes[50]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AppendRecord) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AppendRecord) ProtoMessage() {}

func (x *AppendRecord) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[50]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AppendRecord.ProtoReflect.Descriptor instead.
func (*AppendRecord) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{50}
}

func (x *AppendRecord) GetTimestamp() uint64 {
	if x != nil && x.Timestamp != nil {
		return *x.Timestamp
	}
	return 0
}

func (x *AppendRecord) GetHeaders() []*Header {
	if x != nil {
		return x.Headers
	}
	return nil
}

func (x *AppendRecord) GetBody() []byte {
	if x != nil {
		return x.Body
	}
	return nil
}

// Record retrieved from a stream.
type SequencedRecord struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Sequence number assigned to this record.
	SeqNum uint64 `protobuf:"varint,1,opt,name=seq_num,json=seqNum,proto3" json:"seq_num,omitempty"`
	// Timestamp for this record.
	Timestamp uint64 `protobuf:"varint,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Series of name-value pairs for this record.
	Headers []*Header `protobuf:"bytes,2,rep,name=headers,proto3" json:"headers,omitempty"`
	// Body of this record.
	Body          []byte `protobuf:"bytes,3,opt,name=body,proto3" json:"body,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SequencedRecord) Reset() {
	*x = SequencedRecord{}
	mi := &file_s2_proto_msgTypes[51]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SequencedRecord) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SequencedRecord) ProtoMessage() {}

func (x *SequencedRecord) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[51]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SequencedRecord.ProtoReflect.Descriptor instead.
func (*SequencedRecord) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{51}
}

func (x *SequencedRecord) GetSeqNum() uint64 {
	if x != nil {
		return x.SeqNum
	}
	return 0
}

func (x *SequencedRecord) GetTimestamp() uint64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *SequencedRecord) GetHeaders() []*Header {
	if x != nil {
		return x.Headers
	}
	return nil
}

func (x *SequencedRecord) GetBody() []byte {
	if x != nil {
		return x.Body
	}
	return nil
}

// A batch of sequenced records.
type SequencedRecordBatch struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Batch of sequenced records.
	Records       []*SequencedRecord `protobuf:"bytes,1,rep,name=records,proto3" json:"records,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SequencedRecordBatch) Reset() {
	*x = SequencedRecordBatch{}
	mi := &file_s2_proto_msgTypes[52]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SequencedRecordBatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SequencedRecordBatch) ProtoMessage() {}

func (x *SequencedRecordBatch) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[52]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SequencedRecordBatch.ProtoReflect.Descriptor instead.
func (*SequencedRecordBatch) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{52}
}

func (x *SequencedRecordBatch) GetRecords() []*SequencedRecord {
	if x != nil {
		return x.Records
	}
	return nil
}

type StreamConfig_Timestamping struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Timestamping mode for appends that influences how timestamps are handled.
	Mode TimestampingMode `protobuf:"varint,1,opt,name=mode,proto3,enum=s2.v1alpha.TimestampingMode" json:"mode,omitempty"`
	// Allow client-specified timestamps to exceed the arrival time.
	// If this is false or not set, client timestamps will be capped at the arrival time.
	Uncapped      *bool `protobuf:"varint,2,opt,name=uncapped,proto3,oneof" json:"uncapped,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamConfig_Timestamping) Reset() {
	*x = StreamConfig_Timestamping{}
	mi := &file_s2_proto_msgTypes[53]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamConfig_Timestamping) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamConfig_Timestamping) ProtoMessage() {}

func (x *StreamConfig_Timestamping) ProtoReflect() protoreflect.Message {
	mi := &file_s2_proto_msgTypes[53]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamConfig_Timestamping.ProtoReflect.Descriptor instead.
func (*StreamConfig_Timestamping) Descriptor() ([]byte, []int) {
	return file_s2_proto_rawDescGZIP(), []int{46, 0}
}

func (x *StreamConfig_Timestamping) GetMode() TimestampingMode {
	if x != nil {
		return x.Mode
	}
	return TimestampingMode_TIMESTAMPING_MODE_UNSPECIFIED
}

func (x *StreamConfig_Timestamping) GetUncapped() bool {
	if x != nil && x.Uncapped != nil {
		return *x.Uncapped
	}
	return false
}

var File_s2_proto protoreflect.FileDescriptor

const file_s2_proto_rawDesc = "" +
	"\n" +
	"\bs2.proto\x12\n" +
	"s2.v1alpha\x1a google/protobuf/field_mask.proto\"q\n" +
	"\x11ListBasinsRequest\x12\x16\n" +
	"\x06prefix\x18\x01 \x01(\tR\x06prefix\x12\x1f\n" +
	"\vstart_after\x18\x02 \x01(\tR\n" +
	"startAfter\x12\x19\n" +
	"\x05limit\x18\x03 \x01(\x04H\x00R\x05limit\x88\x01\x01B\b\n" +
	"\x06_limit\"^\n" +
	"\x12ListBasinsResponse\x12-\n" +
	"\x06basins\x18\x01 \x03(\v2\x15.s2.v1alpha.BasinInfoR\x06basins\x12\x19\n" +
	"\bhas_more\x18\x02 \x01(\bR\ahasMore\"\x89\x01\n" +
	"\x12CreateBasinRequest\x12\x14\n" +
	"\x05basin\x18\x01 \x01(\tR\x05basin\x12/\n" +
	"\x06config\x18\x02 \x01(\v2\x17.s2.v1alpha.BasinConfigR\x06config\x12,\n" +
	"\x05scope\x18\x03 \x01(\x0e2\x16.s2.v1alpha.BasinScopeR\x05scope\"@\n" +
	"\x13CreateBasinResponse\x12)\n" +
	"\x04info\x18\x01 \x01(\v2\x15.s2.v1alpha.BasinInfoR\x04info\"*\n" +
	"\x12DeleteBasinRequest\x12\x14\n" +
	"\x05basin\x18\x01 \x01(\tR\x05basin\"\x15\n" +
	"\x13DeleteBasinResponse\"-\n" +
	"\x15GetBasinConfigRequest\x12\x14\n" +
	"\x05basin\x18\x01 \x01(\tR\x05basin\"I\n" +
	"\x16GetBasinConfigResponse\x12/\n" +
	"\x06config\x18\x01 \x01(\v2\x17.s2.v1alpha.BasinConfigR\x06config\"\x90\x01\n" +
	"\x17ReconfigureBasinRequest\x12\x14\n" +
	"\x05basin\x18\x01 \x01(\tR\x05basin\x12/\n" +
	"\x06config\x18\x02 \x01(\v2\x17.s2.v1alpha.BasinConfigR\x06config\x12.\n" +
	"\x04mask\x18\x03 \x01(\v2\x1a.google.protobuf.FieldMaskR\x04mask\"K\n" +
	"\x18ReconfigureBasinResponse\x12/\n" +
	"\x06config\x18\x01 \x01(\v2\x17.s2.v1alpha.BasinConfigR\x06config\"J\n" +
	"\x17IssueAccessTokenRequest\x12/\n" +
	"\x04info\x18\x01 \x01(\v2\x1b.s2.v1alpha.AccessTokenInfoR\x04info\"@\n" +
	"\x14ReadWritePermissions\x12\x12\n" +
	"\x04read\x18\x01 \x01(\bR\x04read\x12\x14\n" +
	"\x05write\x18\x02 \x01(\bR\x05write\"\xc8\x01\n" +
	"\x18PermittedOperationGroups\x12:\n" +
	"\aaccount\x18\x01 \x01(\v2 .s2.v1alpha.ReadWritePermissionsR\aaccount\x126\n" +
	"\x05basin\x18\x02 \x01(\v2 .s2.v1alpha.ReadWritePermissionsR\x05basin\x128\n" +
	"\x06stream\x18\x03 \x01(\v2 .s2.v1alpha.ReadWritePermissionsR\x06stream\"*\n" +
	"\x18RevokeAccessTokenRequest\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\"L\n" +
	"\x19RevokeAccessTokenResponse\x12/\n" +
	"\x04info\x18\x01 \x01(\v2\x1b.s2.v1alpha.AccessTokenInfoR\x04info\"w\n" +
	"\x17ListAccessTokensRequest\x12\x16\n" +
	"\x06prefix\x18\x01 \x01(\tR\x06prefix\x12\x1f\n" +
	"\vstart_after\x18\x02 \x01(\tR\n" +
	"startAfter\x12\x19\n" +
	"\x05limit\x18\x03 \x01(\x04H\x00R\x05limit\x88\x01\x01B\b\n" +
	"\x06_limit\"w\n" +
	"\x18ListAccessTokensResponse\x12@\n" +
	"\raccess_tokens\x18\x01 \x03(\v2\x1b.s2.v1alpha.AccessTokenInfoR\faccessTokens\x12\x19\n" +
	"\bhas_more\x18\x02 \x01(\bR\ahasMore\"\xb8\x01\n" +
	"\x0fAccessTokenInfo\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\"\n" +
	"\n" +
	"expires_at\x18\x02 \x01(\rH\x00R\texpiresAt\x88\x01\x01\x12.\n" +
	"\x13auto_prefix_streams\x18\x03 \x01(\bR\x11autoPrefixStreams\x122\n" +
	"\x05scope\x18\x04 \x01(\v2\x1c.s2.v1alpha.AccessTokenScopeR\x05scopeB\r\n" +
	"\v_expires_at\"\xa0\x02\n" +
	"\x10AccessTokenScope\x12/\n" +
	"\x06basins\x18\x01 \x01(\v2\x17.s2.v1alpha.ResourceSetR\x06basins\x121\n" +
	"\astreams\x18\x02 \x01(\v2\x17.s2.v1alpha.ResourceSetR\astreams\x12<\n" +
	"\raccess_tokens\x18\x03 \x01(\v2\x17.s2.v1alpha.ResourceSetR\faccessTokens\x12A\n" +
	"\top_groups\x18\x04 \x01(\v2$.s2.v1alpha.PermittedOperationGroupsR\bopGroups\x12'\n" +
	"\x03ops\x18\x05 \x03(\x0e2\x15.s2.v1alpha.OperationR\x03ops\"K\n" +
	"\vResourceSet\x12\x16\n" +
	"\x05exact\x18\x01 \x01(\tH\x00R\x05exact\x12\x18\n" +
	"\x06prefix\x18\x02 \x01(\tH\x00R\x06prefixB\n" +
	"\n" +
	"\bmatching\"=\n" +
	"\x18IssueAccessTokenResponse\x12!\n" +
	"\faccess_token\x18\x01 \x01(\tR\vaccessToken\"r\n" +
	"\n" +
	"StreamInfo\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x1d\n" +
	"\n" +
	"created_at\x18\x02 \x01(\rR\tcreatedAt\x12\"\n" +
	"\n" +
	"deleted_at\x18\x03 \x01(\rH\x00R\tdeletedAt\x88\x01\x01B\r\n" +
	"\v_deleted_at\"r\n" +
	"\x12ListStreamsRequest\x12\x16\n" +
	"\x06prefix\x18\x01 \x01(\tR\x06prefix\x12\x1f\n" +
	"\vstart_after\x18\x02 \x01(\tR\n" +
	"startAfter\x12\x19\n" +
	"\x05limit\x18\x03 \x01(\x04H\x00R\x05limit\x88\x01\x01B\b\n" +
	"\x06_limit\"b\n" +
	"\x13ListStreamsResponse\x120\n" +
	"\astreams\x18\x01 \x03(\v2\x16.s2.v1alpha.StreamInfoR\astreams\x12\x19\n" +
	"\bhas_more\x18\x02 \x01(\bR\ahasMore\"_\n" +
	"\x13CreateStreamRequest\x12\x16\n" +
	"\x06stream\x18\x01 \x01(\tR\x06stream\x120\n" +
	"\x06config\x18\x02 \x01(\v2\x18.s2.v1alpha.StreamConfigR\x06config\"B\n" +
	"\x14CreateStreamResponse\x12*\n" +
	"\x04info\x18\x01 \x01(\v2\x16.s2.v1alpha.StreamInfoR\x04info\"-\n" +
	"\x13DeleteStreamRequest\x12\x16\n" +
	"\x06stream\x18\x01 \x01(\tR\x06stream\"\x16\n" +
	"\x14DeleteStreamResponse\"0\n" +
	"\x16GetStreamConfigRequest\x12\x16\n" +
	"\x06stream\x18\x01 \x01(\tR\x06stream\"K\n" +
	"\x17GetStreamConfigResponse\x120\n" +
	"\x06config\x18\x01 \x01(\v2\x18.s2.v1alpha.StreamConfigR\x06config\"\x94\x01\n" +
	"\x18ReconfigureStreamRequest\x12\x16\n" +
	"\x06stream\x18\x01 \x01(\tR\x06stream\x120\n" +
	"\x06config\x18\x02 \x01(\v2\x18.s2.v1alpha.StreamConfigR\x06config\x12.\n" +
	"\x04mask\x18\x03 \x01(\v2\x1a.google.protobuf.FieldMaskR\x04mask\"M\n" +
	"\x19ReconfigureStreamResponse\x120\n" +
	"\x06config\x18\x01 \x01(\v2\x18.s2.v1alpha.StreamConfigR\x06config\"*\n" +
	"\x10CheckTailRequest\x12\x16\n" +
	"\x06stream\x18\x01 \x01(\tR\x06stream\"\\\n" +
	"\x11CheckTailResponse\x12 \n" +
	"\fnext_seq_num\x18\x01 \x01(\x04R\n" +
	"nextSeqNum\x12%\n" +
	"\x0elast_timestamp\x18\x02 \x01(\x04R\rlastTimestamp\"\xd0\x01\n" +
	"\vAppendInput\x12\x16\n" +
	"\x06stream\x18\x01 \x01(\tR\x06stream\x122\n" +
	"\arecords\x18\x02 \x03(\v2\x18.s2.v1alpha.AppendRecordR\arecords\x12'\n" +
	"\rmatch_seq_num\x18\x03 \x01(\x04H\x00R\vmatchSeqNum\x88\x01\x01\x12(\n" +
	"\rfencing_token\x18\x04 \x01(\fH\x01R\ffencingToken\x88\x01\x01B\x10\n" +
	"\x0e_match_seq_numB\x10\n" +
	"\x0e_fencing_token\"\xe9\x01\n" +
	"\fAppendOutput\x12\"\n" +
	"\rstart_seq_num\x18\x01 \x01(\x04R\vstartSeqNum\x12'\n" +
	"\x0fstart_timestamp\x18\x04 \x01(\x04R\x0estartTimestamp\x12\x1e\n" +
	"\vend_seq_num\x18\x02 \x01(\x04R\tendSeqNum\x12#\n" +
	"\rend_timestamp\x18\x05 \x01(\x04R\fendTimestamp\x12 \n" +
	"\fnext_seq_num\x18\x03 \x01(\x04R\n" +
	"nextSeqNum\x12%\n" +
	"\x0elast_timestamp\x18\x06 \x01(\x04R\rlastTimestamp\">\n" +
	"\rAppendRequest\x12-\n" +
	"\x05input\x18\x01 \x01(\v2\x17.s2.v1alpha.AppendInputR\x05input\"B\n" +
	"\x0eAppendResponse\x120\n" +
	"\x06output\x18\x01 \x01(\v2\x18.s2.v1alpha.AppendOutputR\x06output\"E\n" +
	"\x14AppendSessionRequest\x12-\n" +
	"\x05input\x18\x01 \x01(\v2\x17.s2.v1alpha.AppendInputR\x05input\"I\n" +
	"\x15AppendSessionResponse\x120\n" +
	"\x06output\x18\x01 \x01(\v2\x18.s2.v1alpha.AppendOutputR\x06output\"z\n" +
	"\n" +
	"ReadOutput\x128\n" +
	"\x05batch\x18\x01 \x01(\v2 .s2.v1alpha.SequencedRecordBatchH\x00R\x05batch\x12\"\n" +
	"\fnext_seq_num\x18\x03 \x01(\x04H\x00R\n" +
	"nextSeqNumB\b\n" +
	"\x06outputJ\x04\b\x02\x10\x03\"\xb9\x01\n" +
	"\vReadRequest\x12\x16\n" +
	"\x06stream\x18\x01 \x01(\tR\x06stream\x12\x19\n" +
	"\aseq_num\x18\x02 \x01(\x04H\x00R\x06seqNum\x12\x1e\n" +
	"\ttimestamp\x18\x04 \x01(\x04H\x00R\ttimestamp\x12!\n" +
	"\vtail_offset\x18\x05 \x01(\x04H\x00R\n" +
	"tailOffset\x12+\n" +
	"\x05limit\x18\x03 \x01(\v2\x15.s2.v1alpha.ReadLimitR\x05limitB\a\n" +
	"\x05start\">\n" +
	"\fReadResponse\x12.\n" +
	"\x06output\x18\x01 \x01(\v2\x16.s2.v1alpha.ReadOutputR\x06output\"U\n" +
	"\tReadLimit\x12\x19\n" +
	"\x05count\x18\x01 \x01(\x04H\x00R\x05count\x88\x01\x01\x12\x19\n" +
	"\x05bytes\x18\x02 \x01(\x04H\x01R\x05bytes\x88\x01\x01B\b\n" +
	"\x06_countB\b\n" +
	"\x06_bytes\"\xe0\x01\n" +
	"\x12ReadSessionRequest\x12\x16\n" +
	"\x06stream\x18\x01 \x01(\tR\x06stream\x12\x19\n" +
	"\aseq_num\x18\x02 \x01(\x04H\x00R\x06seqNum\x12\x1e\n" +
	"\ttimestamp\x18\x05 \x01(\x04H\x00R\ttimestamp\x12!\n" +
	"\vtail_offset\x18\x06 \x01(\x04H\x00R\n" +
	"tailOffset\x12+\n" +
	"\x05limit\x18\x03 \x01(\v2\x15.s2.v1alpha.ReadLimitR\x05limit\x12\x1e\n" +
	"\n" +
	"heartbeats\x18\x04 \x01(\bR\n" +
	"heartbeatsB\a\n" +
	"\x05start\"U\n" +
	"\x13ReadSessionResponse\x123\n" +
	"\x06output\x18\x01 \x01(\v2\x16.s2.v1alpha.ReadOutputH\x00R\x06output\x88\x01\x01B\t\n" +
	"\a_output\"\xbc\x02\n" +
	"\fStreamConfig\x12=\n" +
	"\rstorage_class\x18\x01 \x01(\x0e2\x18.s2.v1alpha.StorageClassR\fstorageClass\x12\x12\n" +
	"\x03age\x18\x02 \x01(\x04H\x00R\x03age\x12I\n" +
	"\ftimestamping\x18\x05 \x01(\v2%.s2.v1alpha.StreamConfig.TimestampingR\ftimestamping\x1an\n" +
	"\fTimestamping\x120\n" +
	"\x04mode\x18\x01 \x01(\x0e2\x1c.s2.v1alpha.TimestampingModeR\x04mode\x12\x1f\n" +
	"\buncapped\x18\x02 \x01(\bH\x00R\buncapped\x88\x01\x01B\v\n" +
	"\t_uncappedB\x12\n" +
	"\x10retention_policyJ\x04\b\x03\x10\x04J\x04\b\x04\x10\x05\"\xc5\x01\n" +
	"\vBasinConfig\x12L\n" +
	"\x15default_stream_config\x18\x01 \x01(\v2\x18.s2.v1alpha.StreamConfigR\x13defaultStreamConfig\x125\n" +
	"\x17create_stream_on_append\x18\x02 \x01(\bR\x14createStreamOnAppend\x121\n" +
	"\x15create_stream_on_read\x18\x03 \x01(\bR\x12createStreamOnRead\"{\n" +
	"\tBasinInfo\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12,\n" +
	"\x05scope\x18\x05 \x01(\x0e2\x16.s2.v1alpha.BasinScopeR\x05scope\x12,\n" +
	"\x05state\x18\x04 \x01(\x0e2\x16.s2.v1alpha.BasinStateR\x05state\"2\n" +
	"\x06Header\x12\x12\n" +
	"\x04name\x18\x01 \x01(\fR\x04name\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value\"\x81\x01\n" +
	"\fAppendRecord\x12!\n" +
	"\ttimestamp\x18\x03 \x01(\x04H\x00R\ttimestamp\x88\x01\x01\x12,\n" +
	"\aheaders\x18\x01 \x03(\v2\x12.s2.v1alpha.HeaderR\aheaders\x12\x12\n" +
	"\x04body\x18\x02 \x01(\fR\x04bodyB\f\n" +
	"\n" +
	"_timestamp\"\x8a\x01\n" +
	"\x0fSequencedRecord\x12\x17\n" +
	"\aseq_num\x18\x01 \x01(\x04R\x06seqNum\x12\x1c\n" +
	"\ttimestamp\x18\x04 \x01(\x04R\ttimestamp\x12,\n" +
	"\aheaders\x18\x02 \x03(\v2\x12.s2.v1alpha.HeaderR\aheaders\x12\x12\n" +
	"\x04body\x18\x03 \x01(\fR\x04body\"M\n" +
	"\x14SequencedRecordBatch\x125\n" +
	"\arecords\x18\x01 \x03(\v2\x1b.s2.v1alpha.SequencedRecordR\arecords*H\n" +
	"\n" +
	"BasinScope\x12\x1b\n" +
	"\x17BASIN_SCOPE_UNSPECIFIED\x10\x00\x12\x1d\n" +
	"\x19BASIN_SCOPE_AWS_US_EAST_1\x10\x01*\xa7\x04\n" +
	"\tOperation\x12\x19\n" +
	"\x15OPERATION_UNSPECIFIED\x10\x00\x12\x19\n" +
	"\x15OPERATION_LIST_BASINS\x10\x01\x12\x1a\n" +
	"\x16OPERATION_CREATE_BASIN\x10\x02\x12\x1a\n" +
	"\x16OPERATION_DELETE_BASIN\x10\x03\x12\x1f\n" +
	"\x1bOPERATION_RECONFIGURE_BASIN\x10\x04\x12\x1e\n" +
	"\x1aOPERATION_GET_BASIN_CONFIG\x10\x05\x12 \n" +
	"\x1cOPERATION_ISSUE_ACCESS_TOKEN\x10\x06\x12!\n" +
	"\x1dOPERATION_REVOKE_ACCESS_TOKEN\x10\a\x12 \n" +
	"\x1cOPERATION_LIST_ACCESS_TOKENS\x10\b\x12\x1a\n" +
	"\x16OPERATION_LIST_STREAMS\x10\t\x12\x1b\n" +
	"\x17OPERATION_CREATE_STREAM\x10\n" +
	"\x12\x1b\n" +
	"\x17OPERATION_DELETE_STREAM\x10\v\x12\x1f\n" +
	"\x1bOPERATION_GET_STREAM_CONFIG\x10\f\x12 \n" +
	"\x1cOPERATION_RECONFIGURE_STREAM\x10\r\x12\x18\n" +
	"\x14OPERATION_CHECK_TAIL\x10\x0e\x12\x14\n" +
	"\x10OPERATION_APPEND\x10\x0f\x12\x12\n" +
	"\x0eOPERATION_READ\x10\x10\x12\x12\n" +
	"\x0eOPERATION_TRIM\x10\x11\x12\x13\n" +
	"\x0fOPERATION_FENCE\x10\x12*d\n" +
	"\fStorageClass\x12\x1d\n" +
	"\x19STORAGE_CLASS_UNSPECIFIED\x10\x00\x12\x1a\n" +
	"\x16STORAGE_CLASS_STANDARD\x10\x01\x12\x19\n" +
	"\x15STORAGE_CLASS_EXPRESS\x10\x02*\x9f\x01\n" +
	"\x10TimestampingMode\x12!\n" +
	"\x1dTIMESTAMPING_MODE_UNSPECIFIED\x10\x00\x12#\n" +
	"\x1fTIMESTAMPING_MODE_CLIENT_PREFER\x10\x01\x12$\n" +
	" TIMESTAMPING_MODE_CLIENT_REQUIRE\x10\x02\x12\x1d\n" +
	"\x19TIMESTAMPING_MODE_ARRIVAL\x10\x03*u\n" +
	"\n" +
	"BasinState\x12\x1b\n" +
	"\x17BASIN_STATE_UNSPECIFIED\x10\x00\x12\x16\n" +
	"\x12BASIN_STATE_ACTIVE\x10\x01\x12\x18\n" +
	"\x14BASIN_STATE_CREATING\x10\x02\x12\x18\n" +
	"\x14BASIN_STATE_DELETING\x10\x032\xf8\x05\n" +
	"\x0eAccountService\x12P\n" +
	"\n" +
	"ListBasins\x12\x1d.s2.v1alpha.ListBasinsRequest\x1a\x1e.s2.v1alpha.ListBasinsResponse\"\x03\x90\x02\x01\x12S\n" +
	"\vCreateBasin\x12\x1e.s2.v1alpha.CreateBasinRequest\x1a\x1f.s2.v1alpha.CreateBasinResponse\"\x03\x90\x02\x02\x12S\n" +
	"\vDeleteBasin\x12\x1e.s2.v1alpha.DeleteBasinRequest\x1a\x1f.s2.v1alpha.DeleteBasinResponse\"\x03\x90\x02\x02\x12b\n" +
	"\x10ReconfigureBasin\x12#.s2.v1alpha.ReconfigureBasinRequest\x1a$.s2.v1alpha.ReconfigureBasinResponse\"\x03\x90\x02\x02\x12\\\n" +
	"\x0eGetBasinConfig\x12!.s2.v1alpha.GetBasinConfigRequest\x1a\".s2.v1alpha.GetBasinConfigResponse\"\x03\x90\x02\x01\x12]\n" +
	"\x10IssueAccessToken\x12#.s2.v1alpha.IssueAccessTokenRequest\x1a$.s2.v1alpha.IssueAccessTokenResponse\x12e\n" +
	"\x11RevokeAccessToken\x12$.s2.v1alpha.RevokeAccessTokenRequest\x1a%.s2.v1alpha.RevokeAccessTokenResponse\"\x03\x90\x02\x02\x12b\n" +
	"\x10ListAccessTokens\x12#.s2.v1alpha.ListAccessTokensRequest\x1a$.s2.v1alpha.ListAccessTokensResponse\"\x03\x90\x02\x012\xdb\x03\n" +
	"\fBasinService\x12S\n" +
	"\vListStreams\x12\x1e.s2.v1alpha.ListStreamsRequest\x1a\x1f.s2.v1alpha.ListStreamsResponse\"\x03\x90\x02\x01\x12V\n" +
	"\fCreateStream\x12\x1f.s2.v1alpha.CreateStreamRequest\x1a .s2.v1alpha.CreateStreamResponse\"\x03\x90\x02\x02\x12V\n" +
	"\fDeleteStream\x12\x1f.s2.v1alpha.DeleteStreamRequest\x1a .s2.v1alpha.DeleteStreamResponse\"\x03\x90\x02\x02\x12_\n" +
	"\x0fGetStreamConfig\x12\".s2.v1alpha.GetStreamConfigRequest\x1a#.s2.v1alpha.GetStreamConfigResponse\"\x03\x90\x02\x01\x12e\n" +
	"\x11ReconfigureStream\x12$.s2.v1alpha.ReconfigureStreamRequest\x1a%.s2.v1alpha.ReconfigureStreamResponse\"\x03\x90\x02\x022\x90\x03\n" +
	"\rStreamService\x12M\n" +
	"\tCheckTail\x12\x1c.s2.v1alpha.CheckTailRequest\x1a\x1d.s2.v1alpha.CheckTailResponse\"\x03\x90\x02\x01\x12?\n" +
	"\x06Append\x12\x19.s2.v1alpha.AppendRequest\x1a\x1a.s2.v1alpha.AppendResponse\x12X\n" +
	"\rAppendSession\x12 .s2.v1alpha.AppendSessionRequest\x1a!.s2.v1alpha.AppendSessionResponse(\x010\x01\x12>\n" +
	"\x04Read\x12\x17.s2.v1alpha.ReadRequest\x1a\x18.s2.v1alpha.ReadResponse\"\x03\x90\x02\x01\x12U\n" +
	"\vReadSession\x12\x1e.s2.v1alpha.ReadSessionRequest\x1a\x1f.s2.v1alpha.ReadSessionResponse\"\x03\x90\x02\x010\x01B\x0e\n" +
	"\n" +
	"s2.v1alphaP\x01b\x06proto3"

var (
	file_s2_proto_rawDescOnce sync.Once
	file_s2_proto_rawDescData []byte
)

func file_s2_proto_rawDescGZIP() []byte {
	file_s2_proto_rawDescOnce.Do(func() {
		file_s2_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_s2_proto_rawDesc), len(file_s2_proto_rawDesc)))
	})
	return file_s2_proto_rawDescData
}

var file_s2_proto_enumTypes = make([]protoimpl.EnumInfo, 5)
var file_s2_proto_msgTypes = make([]protoimpl.MessageInfo, 54)
var file_s2_proto_goTypes = []any{
	(BasinScope)(0),                   // 0: s2.v1alpha.BasinScope
	(Operation)(0),                    // 1: s2.v1alpha.Operation
	(StorageClass)(0),                 // 2: s2.v1alpha.StorageClass
	(TimestampingMode)(0),             // 3: s2.v1alpha.TimestampingMode
	(BasinState)(0),                   // 4: s2.v1alpha.BasinState
	(*ListBasinsRequest)(nil),         // 5: s2.v1alpha.ListBasinsRequest
	(*ListBasinsResponse)(nil),        // 6: s2.v1alpha.ListBasinsResponse
	(*CreateBasinRequest)(nil),        // 7: s2.v1alpha.CreateBasinRequest
	(*CreateBasinResponse)(nil),       // 8: s2.v1alpha.CreateBasinResponse
	(*DeleteBasinRequest)(nil),        // 9: s2.v1alpha.DeleteBasinRequest
	(*DeleteBasinResponse)(nil),       // 10: s2.v1alpha.DeleteBasinResponse
	(*GetBasinConfigRequest)(nil),     // 11: s2.v1alpha.GetBasinConfigRequest
	(*GetBasinConfigResponse)(nil),    // 12: s2.v1alpha.GetBasinConfigResponse
	(*ReconfigureBasinRequest)(nil),   // 13: s2.v1alpha.ReconfigureBasinRequest
	(*ReconfigureBasinResponse)(nil),  // 14: s2.v1alpha.ReconfigureBasinResponse
	(*IssueAccessTokenRequest)(nil),   // 15: s2.v1alpha.IssueAccessTokenRequest
	(*ReadWritePermissions)(nil),      // 16: s2.v1alpha.ReadWritePermissions
	(*PermittedOperationGroups)(nil),  // 17: s2.v1alpha.PermittedOperationGroups
	(*RevokeAccessTokenRequest)(nil),  // 18: s2.v1alpha.RevokeAccessTokenRequest
	(*RevokeAccessTokenResponse)(nil), // 19: s2.v1alpha.RevokeAccessTokenResponse
	(*ListAccessTokensRequest)(nil),   // 20: s2.v1alpha.ListAccessTokensRequest
	(*ListAccessTokensResponse)(nil),  // 21: s2.v1alpha.ListAccessTokensResponse
	(*AccessTokenInfo)(nil),           // 22: s2.v1alpha.AccessTokenInfo
	(*AccessTokenScope)(nil),          // 23: s2.v1alpha.AccessTokenScope
	(*ResourceSet)(nil),               // 24: s2.v1alpha.ResourceSet
	(*IssueAccessTokenResponse)(nil),  // 25: s2.v1alpha.IssueAccessTokenResponse
	(*StreamInfo)(nil),                // 26: s2.v1alpha.StreamInfo
	(*ListStreamsRequest)(nil),        // 27: s2.v1alpha.ListStreamsRequest
	(*ListStreamsResponse)(nil),       // 28: s2.v1alpha.ListStreamsResponse
	(*CreateStreamRequest)(nil),       // 29: s2.v1alpha.CreateStreamRequest
	(*CreateStreamResponse)(nil),      // 30: s2.v1alpha.CreateStreamResponse
	(*DeleteStreamRequest)(nil),       // 31: s2.v1alpha.DeleteStreamRequest
	(*DeleteStreamResponse)(nil),      // 32: s2.v1alpha.DeleteStreamResponse
	(*GetStreamConfigRequest)(nil),    // 33: s2.v1alpha.GetStreamConfigRequest
	(*GetStreamConfigResponse)(nil),   // 34: s2.v1alpha.GetStreamConfigResponse
	(*ReconfigureStreamRequest)(nil),  // 35: s2.v1alpha.ReconfigureStreamRequest
	(*ReconfigureStreamResponse)(nil), // 36: s2.v1alpha.ReconfigureStreamResponse
	(*CheckTailRequest)(nil),          // 37: s2.v1alpha.CheckTailRequest
	(*CheckTailResponse)(nil),         // 38: s2.v1alpha.CheckTailResponse
	(*AppendInput)(nil),               // 39: s2.v1alpha.AppendInput
	(*AppendOutput)(nil),              // 40: s2.v1alpha.AppendOutput
	(*AppendRequest)(nil),             // 41: s2.v1alpha.AppendRequest
	(*AppendResponse)(nil),            // 42: s2.v1alpha.AppendResponse
	(*AppendSessionRequest)(nil),      // 43: s2.v1alpha.AppendSessionRequest
	(*AppendSessionResponse)(nil),     // 44: s2.v1alpha.AppendSessionResponse
	(*ReadOutput)(nil),                // 45: s2.v1alpha.ReadOutput
	(*ReadRequest)(nil),               // 46: s2.v1alpha.ReadRequest
	(*ReadResponse)(nil),              // 47: s2.v1alpha.ReadResponse
	(*ReadLimit)(nil),                 // 48: s2.v1alpha.ReadLimit
	(*ReadSessionRequest)(nil),        // 49: s2.v1alpha.ReadSessionRequest
	(*ReadSessionResponse)(nil),       // 50: s2.v1alpha.ReadSessionResponse
	(*StreamConfig)(nil),              // 51: s2.v1alpha.StreamConfig
	(*BasinConfig)(nil),               // 52: s2.v1alpha.BasinConfig
	(*BasinInfo)(nil),                 // 53: s2.v1alpha.BasinInfo
	(*Header)(nil),                    // 54: s2.v1alpha.Header
	(*AppendRecord)(nil),              // 55: s2.v1alpha.AppendRecord
	(*SequencedRecord)(nil),           // 56: s2.v1alpha.SequencedRecord
	(*SequencedRecordBatch)(nil),      // 57: s2.v1alpha.SequencedRecordBatch
	(*StreamConfig_Timestamping)(nil), // 58: s2.v1alpha.StreamConfig.Timestamping
	(*fieldmaskpb.FieldMask)(nil),     // 59: google.protobuf.FieldMask
}
var file_s2_proto_depIdxs = []int32{
	53, // 0: s2.v1alpha.ListBasinsResponse.basins:type_name -> s2.v1alpha.BasinInfo
	52, // 1: s2.v1alpha.CreateBasinRequest.config:type_name -> s2.v1alpha.BasinConfig
	0,  // 2: s2.v1alpha.CreateBasinRequest.scope:type_name -> s2.v1alpha.BasinScope
	53, // 3: s2.v1alpha.CreateBasinResponse.info:type_name -> s2.v1alpha.BasinInfo
	52, // 4: s2.v1alpha.GetBasinConfigResponse.config:type_name -> s2.v1alpha.BasinConfig
	52, // 5: s2.v1alpha.ReconfigureBasinRequest.config:type_name -> s2.v1alpha.BasinConfig
	59, // 6: s2.v1alpha.ReconfigureBasinRequest.mask:type_name -> google.protobuf.FieldMask
	52, // 7: s2.v1alpha.ReconfigureBasinResponse.config:type_name -> s2.v1alpha.BasinConfig
	22, // 8: s2.v1alpha.IssueAccessTokenRequest.info:type_name -> s2.v1alpha.AccessTokenInfo
	16, // 9: s2.v1alpha.PermittedOperationGroups.account:type_name -> s2.v1alpha.ReadWritePermissions
	16, // 10: s2.v1alpha.PermittedOperationGroups.basin:type_name -> s2.v1alpha.ReadWritePermissions
	16, // 11: s2.v1alpha.PermittedOperationGroups.stream:type_name -> s2.v1alpha.ReadWritePermissions
	22, // 12: s2.v1alpha.RevokeAccessTokenResponse.info:type_name -> s2.v1alpha.AccessTokenInfo
	22, // 13: s2.v1alpha.ListAccessTokensResponse.access_tokens:type_name -> s2.v1alpha.AccessTokenInfo
	23, // 14: s2.v1alpha.AccessTokenInfo.scope:type_name -> s2.v1alpha.AccessTokenScope
	24, // 15: s2.v1alpha.AccessTokenScope.basins:type_name -> s2.v1alpha.ResourceSet
	24, // 16: s2.v1alpha.AccessTokenScope.streams:type_name -> s2.v1alpha.ResourceSet
	24, // 17: s2.v1alpha.AccessTokenScope.access_tokens:type_name -> s2.v1alpha.ResourceSet
	17, // 18: s2.v1alpha.AccessTokenScope.op_groups:type_name -> s2.v1alpha.PermittedOperationGroups
	1,  // 19: s2.v1alpha.AccessTokenScope.ops:type_name -> s2.v1alpha.Operation
	26, // 20: s2.v1alpha.ListStreamsResponse.streams:type_name -> s2.v1alpha.StreamInfo
	51, // 21: s2.v1alpha.CreateStreamRequest.config:type_name -> s2.v1alpha.StreamConfig
	26, // 22: s2.v1alpha.CreateStreamResponse.info:type_name -> s2.v1alpha.StreamInfo
	51, // 23: s2.v1alpha.GetStreamConfigResponse.config:type_name -> s2.v1alpha.StreamConfig
	51, // 24: s2.v1alpha.ReconfigureStreamRequest.config:type_name -> s2.v1alpha.StreamConfig
	59, // 25: s2.v1alpha.ReconfigureStreamRequest.mask:type_name -> google.protobuf.FieldMask
	51, // 26: s2.v1alpha.ReconfigureStreamResponse.config:type_name -> s2.v1alpha.StreamConfig
	55, // 27: s2.v1alpha.AppendInput.records:type_name -> s2.v1alpha.AppendRecord
	39, // 28: s2.v1alpha.AppendRequest.input:type_name -> s2.v1alpha.AppendInput
	40, // 29: s2.v1alpha.AppendResponse.output:type_name -> s2.v1alpha.AppendOutput
	39, // 30: s2.v1alpha.AppendSessionRequest.input:type_name -> s2.v1alpha.AppendInput
	40, // 31: s2.v1alpha.AppendSessionResponse.output:type_name -> s2.v1alpha.AppendOutput
	57, // 32: s2.v1alpha.ReadOutput.batch:type_name -> s2.v1alpha.SequencedRecordBatch
	48, // 33: s2.v1alpha.ReadRequest.limit:type_name -> s2.v1alpha.ReadLimit
	45, // 34: s2.v1alpha.ReadResponse.output:type_name -> s2.v1alpha.ReadOutput
	48, // 35: s2.v1alpha.ReadSessionRequest.limit:type_name -> s2.v1alpha.ReadLimit
	45, // 36: s2.v1alpha.ReadSessionResponse.output:type_name -> s2.v1alpha.ReadOutput
	2,  // 37: s2.v1alpha.StreamConfig.storage_class:type_name -> s2.v1alpha.StorageClass
	58, // 38: s2.v1alpha.StreamConfig.timestamping:type_name -> s2.v1alpha.StreamConfig.Timestamping
	51, // 39: s2.v1alpha.BasinConfig.default_stream_config:type_name -> s2.v1alpha.StreamConfig
	0,  // 40: s2.v1alpha.BasinInfo.scope:type_name -> s2.v1alpha.BasinScope
	4,  // 41: s2.v1alpha.BasinInfo.state:type_name -> s2.v1alpha.BasinState
	54, // 42: s2.v1alpha.AppendRecord.headers:type_name -> s2.v1alpha.Header
	54, // 43: s2.v1alpha.SequencedRecord.headers:type_name -> s2.v1alpha.Header
	56, // 44: s2.v1alpha.SequencedRecordBatch.records:type_name -> s2.v1alpha.SequencedRecord
	3,  // 45: s2.v1alpha.StreamConfig.Timestamping.mode:type_name -> s2.v1alpha.TimestampingMode
	5,  // 46: s2.v1alpha.AccountService.ListBasins:input_type -> s2.v1alpha.ListBasinsRequest
	7,  // 47: s2.v1alpha.AccountService.CreateBasin:input_type -> s2.v1alpha.CreateBasinRequest
	9,  // 48: s2.v1alpha.AccountService.DeleteBasin:input_type -> s2.v1alpha.DeleteBasinRequest
	13, // 49: s2.v1alpha.AccountService.ReconfigureBasin:input_type -> s2.v1alpha.ReconfigureBasinRequest
	11, // 50: s2.v1alpha.AccountService.GetBasinConfig:input_type -> s2.v1alpha.GetBasinConfigRequest
	15, // 51: s2.v1alpha.AccountService.IssueAccessToken:input_type -> s2.v1alpha.IssueAccessTokenRequest
	18, // 52: s2.v1alpha.AccountService.RevokeAccessToken:input_type -> s2.v1alpha.RevokeAccessTokenRequest
	20, // 53: s2.v1alpha.AccountService.ListAccessTokens:input_type -> s2.v1alpha.ListAccessTokensRequest
	27, // 54: s2.v1alpha.BasinService.ListStreams:input_type -> s2.v1alpha.ListStreamsRequest
	29, // 55: s2.v1alpha.BasinService.CreateStream:input_type -> s2.v1alpha.CreateStreamRequest
	31, // 56: s2.v1alpha.BasinService.DeleteStream:input_type -> s2.v1alpha.DeleteStreamRequest
	33, // 57: s2.v1alpha.BasinService.GetStreamConfig:input_type -> s2.v1alpha.GetStreamConfigRequest
	35, // 58: s2.v1alpha.BasinService.ReconfigureStream:input_type -> s2.v1alpha.ReconfigureStreamRequest
	37, // 59: s2.v1alpha.StreamService.CheckTail:input_type -> s2.v1alpha.CheckTailRequest
	41, // 60: s2.v1alpha.StreamService.Append:input_type -> s2.v1alpha.AppendRequest
	43, // 61: s2.v1alpha.StreamService.AppendSession:input_type -> s2.v1alpha.AppendSessionRequest
	46, // 62: s2.v1alpha.StreamService.Read:input_type -> s2.v1alpha.ReadRequest
	49, // 63: s2.v1alpha.StreamService.ReadSession:input_type -> s2.v1alpha.ReadSessionRequest
	6,  // 64: s2.v1alpha.AccountService.ListBasins:output_type -> s2.v1alpha.ListBasinsResponse
	8,  // 65: s2.v1alpha.AccountService.CreateBasin:output_type -> s2.v1alpha.CreateBasinResponse
	10, // 66: s2.v1alpha.AccountService.DeleteBasin:output_type -> s2.v1alpha.DeleteBasinResponse
	14, // 67: s2.v1alpha.AccountService.ReconfigureBasin:output_type -> s2.v1alpha.ReconfigureBasinResponse
	12, // 68: s2.v1alpha.AccountService.GetBasinConfig:output_type -> s2.v1alpha.GetBasinConfigResponse
	25, // 69: s2.v1alpha.AccountService.IssueAccessToken:output_type -> s2.v1alpha.IssueAccessTokenResponse
	19, // 70: s2.v1alpha.AccountService.RevokeAccessToken:output_type -> s2.v1alpha.RevokeAccessTokenResponse
	21, // 71: s2.v1alpha.AccountService.ListAccessTokens:output_type -> s2.v1alpha.ListAccessTokensResponse
	28, // 72: s2.v1alpha.BasinService.ListStreams:output_type -> s2.v1alpha.ListStreamsResponse
	30, // 73: s2.v1alpha.BasinService.CreateStream:output_type -> s2.v1alpha.CreateStreamResponse
	32, // 74: s2.v1alpha.BasinService.DeleteStream:output_type -> s2.v1alpha.DeleteStreamResponse
	34, // 75: s2.v1alpha.BasinService.GetStreamConfig:output_type -> s2.v1alpha.GetStreamConfigResponse
	36, // 76: s2.v1alpha.BasinService.ReconfigureStream:output_type -> s2.v1alpha.ReconfigureStreamResponse
	38, // 77: s2.v1alpha.StreamService.CheckTail:output_type -> s2.v1alpha.CheckTailResponse
	42, // 78: s2.v1alpha.StreamService.Append:output_type -> s2.v1alpha.AppendResponse
	44, // 79: s2.v1alpha.StreamService.AppendSession:output_type -> s2.v1alpha.AppendSessionResponse
	47, // 80: s2.v1alpha.StreamService.Read:output_type -> s2.v1alpha.ReadResponse
	50, // 81: s2.v1alpha.StreamService.ReadSession:output_type -> s2.v1alpha.ReadSessionResponse
	64, // [64:82] is the sub-list for method output_type
	46, // [46:64] is the sub-list for method input_type
	46, // [46:46] is the sub-list for extension type_name
	46, // [46:46] is the sub-list for extension extendee
	0,  // [0:46] is the sub-list for field type_name
}

func init() { file_s2_proto_init() }
func file_s2_proto_init() {
	if File_s2_proto != nil {
		return
	}
	file_s2_proto_msgTypes[0].OneofWrappers = []any{}
	file_s2_proto_msgTypes[15].OneofWrappers = []any{}
	file_s2_proto_msgTypes[17].OneofWrappers = []any{}
	file_s2_proto_msgTypes[19].OneofWrappers = []any{
		(*ResourceSet_Exact)(nil),
		(*ResourceSet_Prefix)(nil),
	}
	file_s2_proto_msgTypes[21].OneofWrappers = []any{}
	file_s2_proto_msgTypes[22].OneofWrappers = []any{}
	file_s2_proto_msgTypes[34].OneofWrappers = []any{}
	file_s2_proto_msgTypes[40].OneofWrappers = []any{
		(*ReadOutput_Batch)(nil),
		(*ReadOutput_NextSeqNum)(nil),
	}
	file_s2_proto_msgTypes[41].OneofWrappers = []any{
		(*ReadRequest_SeqNum)(nil),
		(*ReadRequest_Timestamp)(nil),
		(*ReadRequest_TailOffset)(nil),
	}
	file_s2_proto_msgTypes[43].OneofWrappers = []any{}
	file_s2_proto_msgTypes[44].OneofWrappers = []any{
		(*ReadSessionRequest_SeqNum)(nil),
		(*ReadSessionRequest_Timestamp)(nil),
		(*ReadSessionRequest_TailOffset)(nil),
	}
	file_s2_proto_msgTypes[45].OneofWrappers = []any{}
	file_s2_proto_msgTypes[46].OneofWrappers = []any{
		(*StreamConfig_Age)(nil),
	}
	file_s2_proto_msgTypes[50].OneofWrappers = []any{}
	file_s2_proto_msgTypes[53].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_s2_proto_rawDesc), len(file_s2_proto_rawDesc)),
			NumEnums:      5,
			NumMessages:   54,
			NumExtensions: 0,
			NumServices:   3,
		},
		GoTypes:           file_s2_proto_goTypes,
		DependencyIndexes: file_s2_proto_depIdxs,
		EnumInfos:         file_s2_proto_enumTypes,
		MessageInfos:      file_s2_proto_msgTypes,
	}.Build()
	File_s2_proto = out.File
	file_s2_proto_goTypes = nil
	file_s2_proto_depIdxs = nil
}
